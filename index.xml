<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coder Yel</title>
    <link>http://freedomofme.github.io/</link>
    <description>Recent content on Coder Yel</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Jan 2017 22:25:33 +0800</lastBuildDate>
    <atom:link href="http://freedomofme.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>多重嵌套布局下滑动冲突解决方案和思路</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%B8%83%E5%B1%80%E4%B8%8B%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Thu, 19 Jan 2017 22:25:33 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%B8%83%E5%B1%80%E4%B8%8B%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E6%80%9D%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>自定义Volley库--HandyVolley</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/HandyVolley/</link>
      <pubDate>Tue, 17 Jan 2017 17:45:23 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/HandyVolley/</guid>
      <description>

&lt;p&gt;本文主要介绍了一个为&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;仿网易新闻APP&lt;/a&gt;的而定制的Volley框架。&lt;/p&gt;

&lt;p&gt;这也是为什么要去修改一个2013年发布的老框架的原因，主要是为了兼容以前的代码。（如果是新上线没有历史负担的项目，网络库(retrofit等)和图片库(glide)等库的性能要更优秀。）&lt;/p&gt;

&lt;h3 id=&#34;一-介绍:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;一、介绍&lt;/h3&gt;

&lt;p&gt;本项目的基于2016年12月29号的原版Volley库开发，也是截止目前的最新版本。从提交日志来看项目代码基于稳定，不会存在重大缺陷。&lt;/p&gt;

&lt;p&gt;目前项目最新版本为1.0.3版本，后期可以会针对做一些微小的优化调整。
本项目兼容原版Volley库的API。&lt;/p&gt;

&lt;p&gt;已经把项目托管于Jcenter仓库，Android项目的话可以用以下语句在Gradle 中引用该项目库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;site.okhttp.codeyel:HandyVolley:1.0.3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第二类-更新细节:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;第二类：更新细节&lt;/h3&gt;

&lt;h5 id=&#34;1-0-0:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.0&lt;/h5&gt;

&lt;p&gt;Fork基于2016年12月29号的原版Volley库&lt;/p&gt;

&lt;h5 id=&#34;1-0-1:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.1&lt;/h5&gt;

&lt;p&gt;更新compileSdkVersion为23&lt;/p&gt;

&lt;h5 id=&#34;1-0-2:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.2&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;增加初始化时的磁盘缓存大小设置&lt;/li&gt;
&lt;li&gt;增加磁盘缓存控制策略：自定义网络响应的Ttl和softTtl。&lt;/li&gt;
&lt;li&gt;增加自定义的缓存设置相对于服务器的缓存策略的优先级控制&lt;/li&gt;
&lt;li&gt;对用户设置不缓存的请求，跳过响应解析操作，微小提升性能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;1-0-3-stable:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.3（Stable）&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;将1.0.2的缓存策略应用于对ImageLoader类&lt;/li&gt;
&lt;li&gt;修复缓存控制Bug&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用样例:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;使用样例&lt;/h3&gt;

&lt;p&gt;经介绍区别于原本Volley的使用方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加初始化时的磁盘缓存大小设置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改方式:Volley.java文件中增加newRequestQueue方法的重载方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxCacheSizeInBytes) 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用方法（其中第三个参数表示瓷片缓存大小为30MB）
    mRequestQueue = Volley.newRequestQueue(mCtx.getApplicationContext(), null, 30 * 1024 * 1024);&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.增加磁盘缓存控制策略：自定义网络响应的Ttl和softTtl&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ttl和softTtl说明
Ttl和softTtl用来用户自定义缓存时间，通常softTtl &amp;lt;= Ttl。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当一个请求的过期时间 &amp;gt; Ttl, 则重新请求服务器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个请求的过期时间 &amp;gt; softTtl &amp;amp;&amp;amp; &amp;lt; Ttl, 则先使用缓存数据做出响应，并同时将该请求发送服务器。（也就是说，响应回调函数会触发两次）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个请求的过期时间 &amp;gt; softTtl，则直接使用本地缓存。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据以上特性，通过设置恰当的Ttl和softTtl，APP可以实现数据的及时展现和刷新。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改细节&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Request.java 增加以下三个属性值和相应的getter：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** this request&#39;s default Soft time limit(unit m       illisecond) if no cache control set by web severs*/
private int mDefaultSoftTtl = 0;


/** this request&#39;s default time limit(unit millisecond) if no cache control set by web severs*/
private int mDefaultTtl = 0;


/**
* Returns true means use the default TTL and soft TTL regardless of the server&#39;s cache control.
* Returns false means server&#39;s cache control has higher priority.
*/
private boolean localCacheControl = false;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;/**
* Returns true if responses to this request should be cached.
*/
public final boolean shouldCache() {
return mShouldCache;
}


/**
* Return this request&#39;s soft time limit (unit seconds).
*/
public int getDefaultSoftTtl() {
  return mDefaultSoftTtl;
}


/**
* Returns this request&#39;s the time limit (unit seconds).
 */
public int getDefaultTtl() {
return mDefaultTtl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中mDefaultSoftTtl表示默认的软缓存时间(单位毫秒)，mDefaultTtl表示默认的缓存时间(单位毫秒)，localCacheControl表示当mDefaultSoftTtl、mDefaultTtl的值和服务器返回的缓存策略冲突时，应该采用哪个数值。（怕大家看不懂我写的蹩脚英文，翻译一下）&lt;/p&gt;

&lt;p&gt;2.同理，在ImageLoader中也增加了以上三个属性和相应的getter。&lt;/p&gt;

&lt;p&gt;方法原型如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
    * Constructs a new ImageLoader.
    * @param queue The RequestQueue to use for making image requests.
    * @param imageCache The cache to use as an L1 cache.
    * @param  defaultSoftTtl this request&#39;s time limit (unit seconds).
    * @param  defaultTtl this request&#39;s soft time limit (unit seconds).
    * @param useLocalCacheControl Returns this request&#39;s cache control priority.
    */
    public ImageLoader(RequestQueue queue, ImageCache imageCache, int defaultSoftTtl, int defaultTtl, boolean useLocalCacheControl) {
        mRequestQueue = queue;
        mCache = imageCache;
        mDefaultSoftTtl = defaultSoftTtl;
        mDefaultTtl = defaultTtl;
        localCacheControl = useLocalCacheControl;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于不经过ImageLoader的Request，如StringRequest，直接覆写Request&lt;T&gt;属性的getter方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new StringRequest(Request.Method.GET, url, responseListener, new DefaultErrorListener(context)) {
    @Override
    public int getDefaultTtl() {
        return 15 * 24 * 3600 * 1000;
    }
    @Override
    public int getDefaultSoftTtl() {
        return 1 * 60 * 1000;
    }
    @Override
    public boolean shouldLocalCacheControl() {
        return true;
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上StringRequest表示默认缓存时间15天，默认软缓存时间1分钟，当与服务器的cache-control冲突时采用此数据为准。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于经过ImageLoader的Request，直接调用ImageLoader的另一个构造方法。&lt;/p&gt;

&lt;p&gt;mImageLoader = new ImageLoader(mRequestQueue, new MyLrnCache(mCtx), 1 * 3600 * 1000, 15 * 24 * 3600 * 1000, true);&lt;/p&gt;

&lt;p&gt;以上ImageLoader表示默认缓存时间15天，默认软缓存时间1小时，当与服务器的cache-control冲突时采用此数据为准。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实际案例&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;Netease&amp;ndash;仿网易新闻Android端APP&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JNI静态与动态注册介绍以及Demo实现</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/demoOfJniRegister/</link>
      <pubDate>Sat, 17 Sep 2016 18:31:12 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/demoOfJniRegister/</guid>
      <description>

&lt;p&gt;一直以来，都觉得Java和Native C的通信没有比较全面直观的教程，知道前几天看见一个大牛的总结。所以接着这个机会，对JNI调用做一些简单记录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JNI的两种注册机制：静态注册和动态注册&lt;/li&gt;
&lt;li&gt;较大型项目JNI的开发框架&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一-jni介绍:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;一、JNI介绍&lt;/h3&gt;

&lt;p&gt;JNI是Java和C进行混合编程的桥梁，其中的核心点就是在Java层声明的Native方法，如何在C层中找到对应的实现。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;静态注册&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;动态注册，需要提供Java中Native方法的方法签名和Native层中对应的实现函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;静态注册:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;静态注册&lt;/h4&gt;

&lt;p&gt;要求C/C++层的函数名符合某种特定的要求:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;包含Java中Native方法的目录信息和方法名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个栗子：
假如以下是StaticTest.java 类代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package jnicourse.hhx.com.jnidemo;

/**
* Created by CodeYel on 16/9/17.
*/
public class StaticTest {
    public native int doAdd(int param1,int param2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这对应的C++中jnicourse_hhx_com_jnidemo_StaticTest.h的函数名是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
* Class:     jnicourse_hhx_com_jnidemo_StaticTest
* Method:    doAdd
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_jnicourse_hhx_com_jnidemo_StaticTest_doAdd (JNIEnv *, jobject, jint, jint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照以上规则进行命名就，在调用到Native的方法时,JVM会去查找是否存在对应函数名的函数，以此实现静态注册。&lt;/p&gt;

&lt;p&gt;附带礼品：NDK提供了javah命令来方便根据.java文件来生成.h。
假如你使用AS作为你的IDE，你可以自定义扩展工具，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;demoOfJniRegister_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;demoOfJniRegister_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用方法：在包含Native声明的方法的文件上右键，选择External Tool中的Javap工具。&lt;/p&gt;

&lt;h4 id=&#34;动态注册:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;动态注册&lt;/h4&gt;

&lt;p&gt;动态注册相对于静态注册，优点是不再根据特定路径查找函数的实现，带来两个好处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;没有了冗杂的函数名，适用于大型项目开发。&lt;/li&gt;
&lt;li&gt;由于不再根据Native函数查找对应的jni层函数，所以首次调用速度比静态注册快。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开发者需要自行提供Java层和C/C++层中的映射关系。&lt;/p&gt;

&lt;p&gt;一种可行的方法是基于JNI重载JNI_OnLoad()，在其中对函数进行动态注册。&lt;/p&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;

&lt;p&gt;DynamicTest.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package jnicourse.hhx.com.jnidemo;

/**
 * Created by CodeYel on 16/9/17.
 */
public class DynamicTest {
    public native int doTwo(int param1, int param2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DynamicBind.cpp&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以下三个部分完成了对方法的动态注册任务。此步骤涉及到如何获取Java函数的问题。具体请查看文末的参考文献，点击此&lt;a href=&#34;http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/&#34;&gt;Link&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static const char *className = &amp;quot;jnicourse/hhx/com/jnidemo/DynamicTest&amp;quot;;


static JNINativeMethod gJni_Methods_DynamicTest[] = {
{&amp;quot;doTwo&amp;quot;, &amp;quot;(II)I&amp;quot;, (void*)addTwoNumber},
};


static int jniRegisterNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods)
{
jclass clazz;


 clazz = (env)-&amp;gt;FindClass( className);
 if (clazz == NULL) {


    return -1;
}
int result = 0;
if ((env)-&amp;gt;RegisterNatives(clazz, gMethods, numMethods) &amp;lt; 0) {


    result = -1;
}
(env)-&amp;gt;DeleteLocalRef(clazz);
return result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重载JNI_OnLoad函数，并在其中调用jniRegisterNativeMethods函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jint JNI_OnLoad(JavaVM* vm, void* reserved){


JNIEnv* env = NULL;
jint result = -1;


if (vm-&amp;gt;GetEnv((void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {
    return result;
}


jniRegisterNativeMethods(env, className, gJni_Methods_DynamicTest, sizeof(gJni_Methods_DynamicTest) / sizeof(JNINativeMethod));


return JNI_VERSION_1_4;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PS：在函数返回值方面，可以做一些定制，来根据返回值判断调用jniRegisterNativeMethods是否成功。&lt;/p&gt;

&lt;h3 id=&#34;二-简单jni开发框架介绍:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;二、简单JNI开发框架介绍&lt;/h3&gt;

&lt;p&gt;结构如下：
&lt;img src=&#34;demoOfJniRegiste_4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;动态注册框架:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;动态注册框架&lt;/h4&gt;

&lt;p&gt;主要由：JniHelper.h和JniHelper.cpp构成。&lt;/p&gt;

&lt;p&gt;是上文介绍的动态注册方法做了一个简单的封装，具体请看DEMO中的DynamicBind2.h和DynamicBind2.cpp文件实现。&lt;/p&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在需要动态注册的文件中，引入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;util/JniHelper.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义一个函数进行注册：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jint register_DT2(JNIEnv * env) {
    return jniRegisterNativeMethods(env, className2, gJni_Methods_DynamicTest2, NELEM(gJni_Methods_DynamicTest2));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在上文的JNI_OnLoad函数进行调用register_DT2函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;log框架:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;Log框架&lt;/h4&gt;

&lt;p&gt;主要由：JniDebug.h和JniDebug.cpp构成。
做了一个简单的实现，具体请看文末贴出的文本DEMO的链接。&lt;/p&gt;

&lt;p&gt;注意在Android.mk文件中添加以下语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;注意事项:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;注意事项&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Android.mk中的添加.cpp文件。&lt;/p&gt;

&lt;p&gt;例如以下代码将dynamic，static，util目录下的cpp文件引入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FILE_LIST := $(wildcard $(LOCAL_PATH)/dynamic/*.cpp) \
$(wildcard $(LOCAL_PATH)/static/*.cpp) \
$(wildcard $(LOCAL_PATH)/util/*.cpp)
LOCAL_SRC_FILES :=$(FILE_LIST:$(LOCAL_PATH)/%=%)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;参考文献:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;参考文献&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;很棒的文章，推荐。另外已经和此文作者进行Email沟通。&lt;a href=&#34;http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/&#34;&gt;http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍了一种使用实验性的Gradle进行开发的方法。&lt;a href=&#34;https://github.com/freekite/Android-JNITest&#34;&gt;https://github.com/freekite/Android-JNITest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一篇比较详细的JNI文章。&lt;a href=&#34;https://my.oschina.net/wolfcs/blog/111309&#34;&gt;https://my.oschina.net/wolfcs/blog/111309&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>记Screen命令简单流程</title>
      <link>http://freedomofme.github.io/%E6%9D%82%E6%96%87/%E8%AE%B0Screen%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sat, 13 Aug 2016 01:59:36 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E6%9D%82%E6%96%87/%E8%AE%B0Screen%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B/</guid>
      <description>

&lt;p&gt;&lt;em&gt;明天还要去加班，今夜如此迷人，不敢轻易入睡。Screen误我啊&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;之前一直用Nohup这类简单的命令来后台执行命令。不过最近想抓点东西，后来做个分词，企图发现点什么好玩的东西。你懂得，七夕节，无非就是抓点男女之间的情话。&lt;/p&gt;

&lt;p&gt;结果手头没有爬虫框架，没有代理。。。悲剧，还记得上次自己好好认真写的时候是为了给自己人人网刷票（这网站就是运营、转型不善的电信代表，豆瓣也是类似）。然后就是用Java随便鼓捣了一点(别问我威慑呢么没用Python。。)&lt;/p&gt;

&lt;p&gt;花了二三个小时写好了，打了个jar包，笔记本没电电源，估计跑不到明天早晨回公司就会没电。。。才想起来之前买了一个云服务器，结果ssh连接之后没法后台执行程序。要是以往的话，应该就是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ctrl + Z，然后bg命令了。&lt;/li&gt;
&lt;li&gt;Nohup命令，不过NoHup在关闭了终端之后没法重新回到之前的后台任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过搜索了，发现Screen不错，就试试。&lt;/p&gt;

&lt;h3 id=&#34;正经点-虽然没人看:3bbaff0247f0606dae87a6b87084fdcf&#34;&gt;正经点，虽然没人看&lt;/h3&gt;

&lt;h5 id=&#34;准备:3bbaff0247f0606dae87a6b87084fdcf&#34;&gt;准备&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;安装: 过程请见文末链接。&lt;/li&gt;
&lt;li&gt;结构：Screen可以可以管理多个screen，一个screen可以拥有多个windows。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;开始使用:3bbaff0247f0606dae87a6b87084fdcf&#34;&gt;开始使用&lt;/h5&gt;

&lt;p&gt;将常用命令记录于下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;screen -list 列出screen的基本情况&lt;/li&gt;
&lt;li&gt;screen -t name 新建一个名为name的screen&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后c 在当前screen中新建windows&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后” &amp;ldquo;(双引号) “ 列出当前screen的windows，可以在此切换windows&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后”k“ 删除当前screen的某一个windows。如果一个screen的所有windows都被删除了，那么该screen也会被删除。&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后”A“ 对windows重命名&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后”d“ 退出当前screen 保持后台运行&lt;/li&gt;
&lt;li&gt;screen -r 重新连接一个screen&lt;/li&gt;
&lt;li&gt;screen -p ID 重新连接特定的screen，其中的 ID 是一个数字或名称。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;详细记载请见IBM的developerworks资料库：
&lt;a href=&#34;https://www.ibm.com/developerworks/cn/aix/library/au-gnu_screen/&#34;&gt;https://www.ibm.com/developerworks/cn/aix/library/au-gnu_screen/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>仿网易新闻Android端APP实现</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E4%BB%BF%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BBAndroid%E7%AB%AFAPP%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 06 Apr 2016 17:59:59 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E4%BB%BF%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BBAndroid%E7%AB%AFAPP%E5%AE%9E%E7%8E%B0/</guid>
      <description>

&lt;h2 id=&#34;主要功能展示和代码实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;主要功能展示和代码实现&lt;/h2&gt;

&lt;p&gt;2015年10月份左右，差不多花了一周的时间，实现了一个粗略版本。&lt;/p&gt;

&lt;p&gt;截止目前，实现了包括新闻下的包括头条、体育、娱乐的一系列的新闻展示，以及点击后进入的新闻详情展示。&lt;/p&gt;

&lt;h3 id=&#34;目前效果:0e1910fcdf867805caab27c6340158d2&#34;&gt;目前效果&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;目前效果：&lt;img src=&#34;home.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;更新:0e1910fcdf867805caab27c6340158d2&#34;&gt;更新：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2017-01-18 趁着寒假，解决历史遗留的复杂嵌套布局滑动冲突；完成基于&lt;a href=&#34;https://github.com/freedomofme/HandyVolley&#34;&gt;自定义Volley&lt;/a&gt;的内容预加载而后响应网络回调。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2015-XX-XX 新闻内容的详情展示已经实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;技术实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;技术实现&lt;/h2&gt;

&lt;h3 id=&#34;滑动标签:0e1910fcdf867805caab27c6340158d2&#34;&gt;滑动标签&lt;/h3&gt;

&lt;p&gt;APP总体底部的4个Fragment切换和在每个Fragment中的ViewPage切换, 采用的是LuckyJayce/ViewPagerIndicator的开源框架：地址是&lt;a href=&#34;https://github.com/LuckyJayce/ViewPagerIndicator&#34;&gt;ViewPagerIndicator&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然,若是初次接触，建议学习&lt;a href=&#34;https://developer.android.com/samples/SlidingTabsBasic/index.html&#34;&gt;SlidingTabsBasic&lt;/a&gt;,Google官方教程，简洁实现SlidingTab。&lt;/p&gt;

&lt;h3 id=&#34;列表实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;列表实现&lt;/h3&gt;

&lt;p&gt;新闻列表采用纵向RecyclerView，其中暂时划分为3种类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static enum ITEM_TYPE {
    ITEM_TYPE_BANNER,
    ITEM_TYPE_IMAGE,
    ITEM_TYPE_TEXT
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别表示以下3种类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BANNER：
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914143937664-372953191.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;TEXT：
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914143948320-1282950477.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IMAGE：
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914143954336-1896838803.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ITEM_TYPE_BANNER 采用自定义SwitchImage控件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ITEM_TYPE_TEXT 相对布局&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ITEM_TYPE_IMAGE 水平RecycleView （官方版本为三张图片）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;水平列表效果:0e1910fcdf867805caab27c6340158d2&#34;&gt;水平列表效果&lt;/h3&gt;

&lt;p&gt;本部分介绍ITEM_TYPE_IMAGE的水平滑动列表如何实现。
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914144420304-1934370299.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;经过一番努力，现已实现了列表能够响应以下三种情景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;触摸ITEM_TYPE_IMAGE滑动时：
会先根据滑动夹角判断是水平滑动还是上下滑动。

&lt;ul&gt;
&lt;li&gt;如果是水平滑动。滑动时，水平列表滑动。如果水平列表滑动尽头，也不会触发新闻栏目的切换。&lt;/li&gt;
&lt;li&gt;如果是垂直滑动。则相应整个列表的上下滑动。&lt;/li&gt;
&lt;li&gt;如果用户滑动很短距离（很短时间）就抬起手指，则触发点击事件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;水平列表事件冲突处理:0e1910fcdf867805caab27c6340158d2&#34;&gt;水平列表事件冲突处理&lt;/h3&gt;

&lt;h4 id=&#34;1-实现方式:0e1910fcdf867805caab27c6340158d2&#34;&gt;1. 实现方式&lt;/h4&gt;

&lt;p&gt;水平滑动的处理方式一般有ViewPage，Gallery，HorizontalScrollview等几种。&lt;/p&gt;

&lt;p&gt;这里采用在垂直RecycleView中嵌套水平RecycleView。
主要的布局结构是这样的：
&lt;img src=&#34;layout.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-存在问题:0e1910fcdf867805caab27c6340158d2&#34;&gt;2.存在问题&lt;/h4&gt;

&lt;p&gt;如果不进行如何额外的处理，那么看上去一些正常。但是每次将水平列表滑动尽头并继续滑动时，会触发Viewpage的页面切换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;趁着寒假，已经把这个问题分析处理了。&lt;/strong&gt;
&lt;a href=&#34;http://freedomofme.github.io/开发/多重嵌套布局下滑动冲突解决方案和思路&#34;&gt;解决过程和思路完全复盘，值得一看！&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;  但是当我想对水平RecyclerView中的某张图片进行点击时，出现了onClick函数没有回调的问题，由于笔者水平和时间有限，暂时没有深究这个问题。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;于是采用了onTouch函数做点击响应的回调, 做了如下简单的判断：&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt; 用户是点击图片还是水平滑动RecyclerIView &lt;/del&gt;
&lt;del&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;imageView.setOnTouchListener(new View.OnTouchListener() {
  @Override
 public boolean onTouch(View v, MotionEvent event) {
  //抬起按钮时判断，之前是否滑动了,若没有滑动则响应点击事件
                if (event.getAction() == MotionEvent.ACTION_UP &amp;amp;&amp;amp; !isMoved)
                    mListener.onViewPageTouch((NetworkImageView) v, index);
                else {
                    isMoved = false;
                }
                if (event.getAction() == MotionEvent.ACTION_MOVE) {
                    isMoved = true;
                }
                return true;
            }
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;基于自定义volley预加载和回调刷新:0e1910fcdf867805caab27c6340158d2&#34;&gt;基于自定义Volley预加载和回调刷新&lt;/h3&gt;

&lt;h4 id=&#34;目前效果-1:0e1910fcdf867805caab27c6340158d2&#34;&gt;目前效果&lt;/h4&gt;

&lt;p&gt;首次打开APP时，先显示缓存内容，然后同时请求网络，显示最新内容。&lt;/p&gt;

&lt;h4 id=&#34;最简单的实现方案:0e1910fcdf867805caab27c6340158d2&#34;&gt;最简单的实现方案&lt;/h4&gt;

&lt;p&gt;一般的话，可能会使用数据库之类的存储结构来保存历史新闻。但是，我想简化这个过程，依赖于网络请求框架的缓存来实现。&lt;/p&gt;

&lt;p&gt;一开始想的是给修改Volley源码，为Response.Listener(T response)接口增加一个回调方法onCacheHit(T response)方案,如以下代码所示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public interface Listener&amp;lt;T&amp;gt; {
    /** Called when a response is received. */
    public void onResponse(T response);
    /** 存在缓存 */
    public void onCacheHit(T response);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，经过阅读Volley的源码，发现可以通过修改一个Response的softTTL和TTL来实现以上想法。&lt;/p&gt;

&lt;p&gt;于是根据这个想法，修改出了一个HandyVolley的框架，使用文档见于此处&amp;ndash;&lt;a href=&#34;https://github.com/freedomofme/HandyVolley&#34;&gt;HandyVolley&lt;/a&gt;，并发布于Jcente仓库中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;site.okhttp.codeyel:HandyVolley:1.0.3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;顶部沉浸式状态栏实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;顶部沉浸式状态栏实现&lt;/h3&gt;

&lt;p&gt;参考了这篇文章：
&lt;a href=&#34;http://www.jianshu.com/p/f8374d6267ef&#34;&gt;http://www.jianshu.com/p/f8374d6267ef&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;新闻详情实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;新闻详情实现&lt;/h3&gt;

&lt;p&gt;首先，根据网络返回的数据的样式确定解析方案：&lt;/p&gt;

&lt;p&gt;NewsDisplayActivity.java第70行，展示了一个返回数据Html格式的样例：&lt;a href=&#34;https://github.com/freedomofme/Netease/commit/bb6db85de547d4d5243e17e881bc2116122e52d6&#34;&gt;https://github.com/freedomofme/Netease/commit/bb6db85de547d4d5243e17e881bc2116122e52d6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文采用的方法是通过Android自带的android.text.Html类解析Html和html下&lt;img&gt;标签的图像。
核心代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    URLImageParser p = new URLImageParser(content, this);
    Spanned htmlSpan = Html.fromHtml(body, p, null);
    content.setText(htmlSpan);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的URLImageParser是用来解析&lt;img&gt;标签的，这里有很大的进一步优化的空间。&lt;/p&gt;

&lt;p&gt;这类主要是参考该文，并修正了图片尺寸上的问题。&lt;a href=&#34;http://stackoverflow.com/questions/15617210/android-html-fromhtml-with-images/15617341#15617341&#34;&gt;http://stackoverflow.com/questions/15617210/android-html-fromhtml-with-images/15617341#15617341&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，除了用TextView来展示Html（在Android
中就是Spanned类），也可以使用WebView。
两者的主要区别：
* WebView：加载HTML更为方便（笔者觉得），支持的标签更多，与APP交互需要通过JS接口
* TextView： 除了文本显示，对于其他很多交互行为，需要重写函数。开发者对展示细节的控制能力更强。
详细内容可以参考:&lt;a href=&#34;https://www.ibm.com/developerworks/cn/web/1407_zhangqian_androidhtml/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;数据请求与相应:0e1910fcdf867805caab27c6340158d2&#34;&gt;数据请求与相应&lt;/h3&gt;

&lt;p&gt;采用的是Volley框架，并封装了RequestSingletonFactory工厂类来方便请求。
URLs类中采用反射的方式来读取静态URL的数据。&lt;/p&gt;

&lt;h3 id=&#34;接下来:0e1910fcdf867805caab27c6340158d2&#34;&gt;接下来&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;完善新闻阅读的排版，对于部分网页存在数据不兼容，导致解析的Bug&lt;/li&gt;
&lt;li&gt;增加查看新闻评论功能&lt;/li&gt;
&lt;li&gt;增加用户设置界面&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;下载地址:0e1910fcdf867805caab27c6340158d2&#34;&gt;下载地址&lt;/h3&gt;

&lt;p&gt;本项目将在持续更新，更加完善，项目源码地址：
&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;https://github.com/freedomofme/Netease&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本开源项目仅供学习，不得作为其他用途&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java重排序和happens-before学习思路</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Java%20%E9%87%8D%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Fri, 01 Apr 2016 19:52:07 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Java%20%E9%87%8D%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/</guid>
      <description>&lt;p&gt;鉴于在互联网上大家资料抄袭严重，本文主要介绍学习Java中的重排序和happens-before关系等相关概念的学习思路。建议大家看书系统学习。&lt;/p&gt;

&lt;p&gt;我觉得理解这些概念，比较好的思路是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;知道什么是重排序？
&amp;gt; 重排序是编译器和处理器为了优化性能而对指令执行顺序进行重新排序。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;现在你已经知道了什么是重排序，认识下重排序的发生位置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编译器重排序&lt;/li&gt;
&lt;li&gt;指令级并行重排序&lt;/li&gt;
&lt;li&gt;内存系统重排序&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;理解单线程程序中可能发生指令的重排序&lt;/p&gt;

&lt;p&gt;这就是说在单线程中，编译器也会进行重排序。但是为什么我以前写了这么久单线程的Java程序，都没有发现指令重排序这个问题？&lt;/p&gt;

&lt;p&gt;原因是java遵从as-if-serial语义，即单线程的程序即使发生了重排序，程序的执行结果不能被改变。所以，即使发生了重排序，执行结果是一样的，所以你感觉不到。&lt;/p&gt;

&lt;p&gt;比如说，对于有数据依赖的语句进行重排序，就会改变结果，所以会禁止此种情况的重排序。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;理解happens-before的定义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见。且第一个操作排在第二个操作之前。&lt;/li&gt;
&lt;li&gt;两个操作之间存在happens-before关系，如果重排序之后的对执行结果没有影响，也可以重排序。即表明不一定存在这个关系就一定不能重排序。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;happens-before规则&lt;/p&gt;

&lt;p&gt;这里有6条：程序次序规则；监视器锁规则；volatile规则；传递性规则等等。
比如：程序次序规则，它要求一个线程中的每个操作，happens-before该线程的任何后续操作。
这里大家去查阅详细资料。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;此时可能会有一个疑惑，既然多线程程序的先后语句满足happens-before规则中程序次序规则，为什么还会重排序？&lt;/p&gt;

&lt;p&gt;其实这个问题前面已经说了，第4点，在多线程程序中，也是由多个单线程组成的。他们中的每一个线程前后是存在happens-before规则。java以单线程的角度来看待这个问题：java认为对线程中语句进行重排序是不会改变结果的。&lt;/p&gt;

&lt;p&gt;因为java又不知道你这个代码是会在多线程里运行还是单线程里运行，它只保证单线程运行时，重排序后不改变执行结果，当这代码在多线程里运行时就可能出现问题。&lt;/p&gt;

&lt;p&gt;所以我们就需要在多线程中进行正确的同步的一个原因。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;学习volatile语义、锁的语义、和final的语义&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;此时就可惜学习java中的Thread的实现和并发容器的实现&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程一：a -&amp;gt; b -&amp;gt; c
线程二：A -&amp;gt; B -&amp;gt; C&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若没有重排序的结果可能是&lt;/p&gt;

&lt;p&gt;a -&amp;gt; A -&amp;gt; B -&amp;gt; b -&amp;gt; c -&amp;gt; C&lt;/p&gt;

&lt;p&gt;也就是单个线程的顺序不变&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若发生了重排序结果可能是&lt;/p&gt;

&lt;p&gt;b -&amp;gt; B -&amp;gt; A -&amp;gt; a -&amp;gt; c -&amp;gt; C&lt;/p&gt;

&lt;p&gt;就要分析里面的代码是否有happens-before的关系以及对每个单线程而言的重拍序是否会改变运行结果来分析。&lt;/p&gt;

&lt;p&gt;本文参考：《并发编写的艺术》&lt;/p&gt;

&lt;p&gt;欢迎批评指正：&lt;a href=&#34;mailto:xiegeixiong@gmail.com&#34;&gt;xiegeixiong@gmail.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何根据二叉树的中序和前序后序推导出整棵二叉树</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%8E%A8%E5%AF%BC%E5%87%BA%E6%95%B4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 01 Apr 2016 19:52:07 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%8E%A8%E5%AF%BC%E5%87%BA%E6%95%B4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>

&lt;p&gt;本文将主要介绍程序的主要计算流程。具体Android APP代码在&lt;a href=&#34;https://github.com/freedomofme/BinaryTreeTraverseCalculate&#34;&gt;请看这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;写作目的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当然是为了为了加深理解二叉树遍历啦&lt;/li&gt;
&lt;li&gt;因为受不了笔试题老出这种题目，所以做出来方便大家以后答题O(∩_∩)O~&lt;/li&gt;
&lt;li&gt;最关键的是，每次遇到这种题目，我只会凑./捂脸&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;so，我决定花一个小时，写个程序一劳永逸，结果还没写完，我就学会了，不需要它了，送给大家~&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先在知道中序的前提下，任意知道一个前序、后序，即可以构建整棵二叉树，也就知道了所有顺序的遍历。&lt;/p&gt;

&lt;h4 id=&#34;由前序中序推导:65af8147e2e31eeb70f80702d9fc030d&#34;&gt;由前序中序推导&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;已知一棵二叉树的前序序列和中序序列，构造该二叉树的过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;根据前序序列的第一个元素建立根结点；&lt;/li&gt;
&lt;li&gt;在中序序列中找到该元素，确定根结点的左右子树的中序序列；&lt;/li&gt;
&lt;li&gt;在前序序列中确定左右子树的前序序列；&lt;/li&gt;
&lt;li&gt;由左子树的前序序列和中序序列建立左子树；&lt;/li&gt;
&lt;li&gt;由右子树的前序序列和中序序列建立右子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;由后序中序推导:65af8147e2e31eeb70f80702d9fc030d&#34;&gt;由后序中序推导&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;已知一棵二叉树的后序序列和中序序列，构造该二叉树的过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;根据后序序列的最后一个元素建立根结点；&lt;/li&gt;
&lt;li&gt;在中序序列中找到该元素，确定根结点的左右子树的中序序列；&lt;/li&gt;
&lt;li&gt;在后序序列中确定左右子树的后序序列；&lt;/li&gt;
&lt;li&gt;由左子树的后序序列和中序序列建立左子树；&lt;/li&gt;
&lt;li&gt;由右子树的后序序列和中序序列建立右子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;引用自：&lt;a href=&#34;http://blog.sina.com.cn/s/blog_8c243ea30102uzwo.html&#34;&gt;http://blog.sina.com.cn/s/blog_8c243ea30102uzwo.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;核心代码:65af8147e2e31eeb70f80702d9fc030d&#34;&gt;核心代码&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public static void calPostOrder(String preString, String midString) {
    if (preString.length() == 0) return;
    if (preString.length() == 1) {
        result.add(preString.charAt(0));
    }
    if (preString.length() &amp;gt; 1) {
        //前序首字母拆分中序字符串           
        String[] resultStrings = midString.split(preString.charAt(0) + &amp;quot;&amp;quot;);
        for (int i = 0; i &amp;lt; resultStrings.length; i++) {
            String newPreString = findSubStringInPreORPostString(preString, resultStrings[i]);
            calPostOrder(newPreString, resultStrings[i]);
        }
        result.add(preString.charAt(0));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中findSubStringInPreORPostString()函数就是从先序字符串中取出对应中序的字符串的子串。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>http://freedomofme.github.io/aboutme/</link>
      <pubDate>Fri, 01 Apr 2016 15:21:43 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/aboutme/</guid>
      <description>&lt;p&gt;你好，我叫Coder Yel，中山大学数据科学学院的研究生一枚，很高兴你的到来，本站关注于一些小众的Java和Android知识的介绍和汇总。&lt;/p&gt;

&lt;p&gt;2016.4.6 完成的博客文章迁移~&lt;/p&gt;

&lt;p&gt;我的邮箱: &lt;a href=&#34;mailto:huanghanxiongchn@gmail.com&#34;&gt;huanghanxiongchn@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的Git: &lt;a href=&#34;https://github.com/freedomofme&#34;&gt;https://github.com/freedomofme&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android 图像压缩，和LRU算法使用的推荐链接</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%20%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%EF%BC%8C%E5%92%8CLRU%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8E%A8%E8%8D%90%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sat, 02 Jan 2016 17:54:06 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%20%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%EF%BC%8C%E5%92%8CLRU%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8E%A8%E8%8D%90%E9%93%BE%E6%8E%A5/</guid>
      <description>&lt;p&gt;近两日，看的关于这些方面的一些教程数十篇，最好的当属google原版的教程了。国内有不少文章是翻译这个链接的。&lt;/p&gt;

&lt;p&gt;需要注意的一点是：Android的SDK中的LRU算法在V4包和Util包中各有一个，推荐使用V4包中的。&lt;/p&gt;

&lt;p&gt;在此，推荐两个链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/intl/ru/training/displaying-bitmaps/process-bitmap.html&#34;&gt;https://developer.android.com/intl/ru/training/displaying-bitmaps/process-bitmap.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://android-developers.blogspot.jp/2010/07/multithreading-for-performance.html&#34;&gt;http://android-developers.blogspot.jp/2010/07/multithreading-for-performance.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中，第二个链接是对第一个链接所讲内容的例子演示，下载地址我已经clone到我的github上了，看了会对内容理解的更加深刻，强烈欢迎下载。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/freedomofme/android-imagedownloader&#34;&gt;https://github.com/freedomofme/android-imagedownloader&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android图片适配，drawable文件夹，低分辨率图片是否必要</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D%EF%BC%8Cdrawable%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E4%BD%8E%E5%88%86%E8%BE%A8%E7%8E%87%E5%9B%BE%E7%89%87%E6%98%AF%E5%90%A6%E5%BF%85%E8%A6%81/</link>
      <pubDate>Sat, 02 Jan 2016 17:50:06 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D%EF%BC%8Cdrawable%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E4%BD%8E%E5%88%86%E8%BE%A8%E7%8E%87%E5%9B%BE%E7%89%87%E6%98%AF%E5%90%A6%E5%BF%85%E8%A6%81/</guid>
      <description>&lt;p&gt;我们知道，Android提供了几种不同分辨率的bitmap，来对应不同手机屏幕的密度。对应关系如下：&lt;/p&gt;

&lt;p&gt;xxhdpi:3.0
xhdpi: 2.0
hdpi: 1.5
mdpi: 1.0
ldpi: 0.75
于是一个问题产生了：&lt;/p&gt;

&lt;p&gt;从接触Android开发时就有了，既然Android能自动转换，为什么还要浪费用户空间去存储低分辨率的图片？&lt;/p&gt;

&lt;p&gt;查了一些资料，终于在Google的开发者网站上找到了解答：
&amp;gt;
Note: Low-density (ldpi) resources aren’t always necessary. When you provide hdpi assets, the system scales them down by one half to properly fit ldpi screens.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://developer.android.com/training/basics/supporting-devices/screens.html&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大概意思就是低分辨率的资源不是总是必要的，当你提供高分辨率的资源了，系统会缩放图片来适应低分率的屏幕。&lt;/p&gt;

&lt;p&gt;问题到此就解答完了。&lt;/p&gt;

&lt;p&gt;有个疑问：就是假如未放置了低分辨率图片，让系统需要时自动转换，是否影响响应速度（系统是否会缓存）？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>记第一次翻译For开源社区</title>
      <link>http://freedomofme.github.io/%E6%9D%82%E6%96%87/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BF%BB%E8%AF%91For%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA/</link>
      <pubDate>Sat, 02 Jan 2016 17:46:45 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E6%9D%82%E6%96%87/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BF%BB%E8%AF%91For%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA/</guid>
      <description>&lt;p&gt;今晚在用火狐的Firebug，有点问题，去火狐社区找答案，结果去了火狐市场，发现还是英文，还有一个邀请翻译的按钮：&lt;/p&gt;

&lt;p&gt;好吧，难得今晚心情不错，就去翻译下吧~~~嘿嘿&lt;/p&gt;

&lt;p&gt;先是注册个了火狐社区的账号，申请做志愿者的翻译工作，随后就挑了这篇文章开始翻译啦~&lt;/p&gt;

&lt;p&gt;其实在两个小时前是这样的，“这个篇文章尚没有中文翻译版”。&lt;/p&gt;

&lt;p&gt;花了半个小时时间，把它从英文版变为了中文版~~~&lt;/p&gt;

&lt;p&gt;这是链接：&lt;a href=&#34;https://support.mozilla.org/zh-CN/kb/%E8%8B%B9%E6%9E%9C%E7%94%B5%E8%84%91-%E5%AE%89%E5%85%A8-%E8%AE%BE%E7%BD%AE-%E7%81%AB%E7%8B%90-%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA&#34;&gt;https://support.mozilla.org/zh-CN/kb/%E8%8B%B9%E6%9E%9C%E7%94%B5%E8%84%91-%E5%AE%89%E5%85%A8-%E8%AE%BE%E7%BD%AE-%E7%81%AB%E7%8B%90-%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;翻译的好烂~，人家审核的妹子还通过了~~~感觉不错&lt;/p&gt;

&lt;p&gt;最后还留了个名&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;哈哈，收到邮件的时候还是蛮开心的
&lt;img src=&#34;33.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android获取联系人示例，从数据库加载，带首字母标签</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%E8%8E%B7%E5%8F%96%E8%81%94%E7%B3%BB%E4%BA%BA%E7%A4%BA%E4%BE%8B%EF%BC%8C%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%B8%A6%E9%A6%96%E5%AD%97%E6%AF%8D%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Fri, 01 Jan 2016 17:59:26 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%E8%8E%B7%E5%8F%96%E8%81%94%E7%B3%BB%E4%BA%BA%E7%A4%BA%E4%BE%8B%EF%BC%8C%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%B8%A6%E9%A6%96%E5%AD%97%E6%AF%8D%E6%A0%87%E7%AD%BE/</guid>
      <description>

&lt;p&gt;这几天打算学习下Android联系人方面的一些东西，之前稍有涉略，不过每次都是浅尝辄止。&lt;/p&gt;

&lt;p&gt;推荐国内两个Link：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fanfq.iteye.com/blog/779569&#34;&gt;Link1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.icodelogic.com/?p=453&#34;&gt;Link2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上两个都是读取联系人。&lt;/p&gt;

&lt;p&gt;第一个Link采用多次查询每次查询一条数据的方式，比较好理解，但是效率底。250条记录（6s）&lt;/p&gt;

&lt;p&gt;第二个Link采用的Querying entities，返回数据集，大大减少了查询次数。250条记录（200ms）。因为采用了联接的数据库查询方式（不大熟悉的话可以温习下数据库方面的知识），大大减少了查询次数。&lt;/p&gt;

&lt;p&gt;google上有对contacts的比较详细的教材,也有讲到到
Querying entities：&lt;a href=&#34;http://developer.android.com/intl/zh-cn/guide/topics/providers/contacts-provider.html&#34;&gt;http://developer.android.com/intl/zh-cn/guide/topics/providers/contacts-provider.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;推荐《精通Android》书里的介绍也不错&lt;/p&gt;

&lt;h3 id=&#34;demo:637a22d20c7bd1c4d18680e663810998&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;根据最开始的两个link，做成一个Demo，给大家参考和批评：&lt;/p&gt;

&lt;p&gt;Demo下载地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://files.cnblogs.com/files/FightForFreedom/ContactsDataBase.zip&#34;&gt;http://files.cnblogs.com/files/FightForFreedom/ContactsDataBase.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;截图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://images0.cnblogs.com/blog2015/739642/201508/091350416436298.png&#34; alt=&#34;http://images0.cnblogs.com/blog2015/739642/201508/091350416436298.png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字符集乱码问题:ISO-8859-1和GBK</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98-ISO-8859-1%E5%92%8CGBK/</link>
      <pubDate>Fri, 01 Jan 2016 17:59:16 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98-ISO-8859-1%E5%92%8CGBK/</guid>
      <description>

&lt;p&gt;首先引用百度知道的问题：
&amp;gt;
&lt;a href=&#34;http://zhidao.baidu.com/question/51342167.html?qbl=relate_question_0&amp;amp;word=%C3%84%C3%A3%C2%BA%C3%83%20%E4%B9%B1%E7%A0%81&#34;&gt;帮忙翻译 ÄãºÃ£¬¿Í»§ÉÐÔ&amp;amp;Uacu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;即：出现了以下字符乱码
ÄãºÃ£¬¿Í»§ÉÐÔÚ¿¼ÂÇÖÐ£¬Ð»Ð»£¡
如何解决？&lt;/p&gt;

&lt;h3 id=&#34;方法一:e4ec21571305cc652d1ed9bd63a35f48&#34;&gt;方法一：&lt;/h3&gt;

&lt;p&gt;String s_iso88591 = new String(&amp;ldquo;ÄãºÃ£¬¿Í»§ÉÐÔÚ¿¼ÂÇÖÐ£¬Ð»Ð»£¡ &amp;ldquo;.getBytes(&amp;ldquo;ISO-8859-1&amp;rdquo;),&amp;ldquo;GBK&amp;rdquo;);
输出s_iso88591即可。&lt;/p&gt;

&lt;h3 id=&#34;方法二:e4ec21571305cc652d1ed9bd63a35f48&#34;&gt;方法二：&lt;/h3&gt;

&lt;p&gt;String testString = &amp;ldquo;你好&amp;rdquo;;
byte[] hold = testString.getBytes(&amp;ldquo;GBK&amp;rdquo;);
for (int i = 0 ; i &amp;lt; hold.length; i++) {
System.out.println((char)(256 + hold[i]));
}
输出: ÄãºÃ&lt;/p&gt;

&lt;p&gt;由此可见好好理解字符集还是相当必要的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅谈Java对象回收的三种方式</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E6%B5%85%E8%B0%88Java%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Fri, 01 Jan 2016 17:59:06 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E6%B5%85%E8%B0%88Java%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>

&lt;p&gt;最近在看Java虚拟机，写点给新手和自己看的东西。&lt;/p&gt;

&lt;h3 id=&#34;第一类-生命周期中止:6029cb9672493498e7785f8d23b0964a&#34;&gt;第一类：生命周期中止&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;void scope（）{
    Test t = new Test();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第二类-对象无引用:6029cb9672493498e7785f8d23b0964a&#34;&gt;第二类：对象无引用&lt;/h3&gt;

&lt;h5 id=&#34;对象的应用被转移:6029cb9672493498e7785f8d23b0964a&#34;&gt;对象的应用被转移：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;void life（）{
   Test t = new Test();
    t = new Test();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;对象被赋值为null:6029cb9672493498e7785f8d23b0964a&#34;&gt;对象被赋值为null&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;void scope（）{
   Test t = new Test();
   t = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于Android的ListView中CheckBox错乱</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%85%B3%E4%BA%8EAndroid%E7%9A%84ListView%E4%B8%ADCheckBox%E9%94%99%E4%B9%B1/</link>
      <pubDate>Fri, 01 Jan 2016 17:57:45 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%85%B3%E4%BA%8EAndroid%E7%9A%84ListView%E4%B8%ADCheckBox%E9%94%99%E4%B9%B1/</guid>
      <description>

&lt;p&gt;本文参考：
&amp;gt; &lt;a href=&#34;http://www.cnblogs.com/xiaowenji/archive/2010/12/08/1900579.html&#34;&gt;ListView中getView的原理＋如何在ListView中放置多个item&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上文中关于说的Android中的Recycler比较模糊，Android会维持屏幕中显示的item+1个对象。但是具体的复用机制没有介绍，建议阅读源码学习。&lt;/p&gt;

&lt;h3 id=&#34;关于checkbox-选中了之后-下滑之后返回就消失的问题:26155ffc16647da895c63731007e82b8&#34;&gt;关于checkBox，选中了之后，下滑之后返回就消失的问题。&lt;/h3&gt;

&lt;p&gt;有以下两种方式供大家参考：&lt;/p&gt;

&lt;p&gt;data是给TextView显示的数据&lt;/p&gt;

&lt;p&gt;isChecked是用来记录CheckBox是否选中的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayList&amp;lt;String&amp;gt; data;
ArrayList&amp;lt;Boolean&amp;gt; isChecked;
 class Holder {
        TextView name;
        CheckBox box;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h4 id=&#34;方法一:26155ffc16647da895c63731007e82b8&#34;&gt;方法一：&lt;/h4&gt;

&lt;p&gt;用onClickedListener,使用这个监听器可以简单的避开CheckedBox选中消失的问题。&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;holder.box.setTag(i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用来给监听器指明选择的索引。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Override
    public View getView(int i, View view, ViewGroup viewGroup) {
        if(view == null) {
            view = LayoutInflater.from(context).inflate(R.layout.list_item, null);
            holder = new Holder();
            holder.box = (CheckBox) view.findViewById(R.id.cb_isChecked);
            holder.name = (TextView) view.findViewById(R.id.tv_name);
            view.setTag(holder);
        } else {
            holder = (Holder) view.getTag();
        }
        holder.name.setText(data.get(i));
        System.out.println(&amp;quot;即将改变成&amp;quot; + isChecked.get(i) + &amp;quot;i&amp;quot; + i);
        holder.box.setChecked(isChecked.get(i));
　　
        holder.box.setTag(i);
        holder.box.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                boolean hold = isChecked.get((Integer) view.getTag());
                isChecked.set((Integer) view.getTag(), !hold);
                System.out.println(&amp;quot;compoundButton.getTag()&amp;quot; + view.getTag());
            }
        });
        return view;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;方法二:26155ffc16647da895c63731007e82b8&#34;&gt;方法二：&lt;/h4&gt;

&lt;p&gt;继续使用onCheckedListener这个监听器，需要注意一些问题。&lt;/p&gt;

&lt;p&gt;代码：和上面的一样，就是把onClickListener改成onCheckedlistener，结果就出现了选中消失的问题。&lt;/p&gt;

&lt;p&gt;仔细看了在logcat中看了输出的结果，发现问题的所在：&lt;/p&gt;

&lt;p&gt;当我们选中一个item时，假设此时item1被选中，下拉列表，到时item1隐藏，item10出现，并复用了item1的结构。&lt;/p&gt;

&lt;p&gt;由于在getView函数中item10被赋值是false，此时，onCheckedListener监听器响应了（如果使用onClickedListener就没有以下问题，因为它再此时不会响应）。&lt;/p&gt;

&lt;p&gt;问题来了：&lt;/p&gt;

&lt;p&gt;因为在onCheckedListener根据view.getTag()来获得索引，而此时的索引是1，就是item1对象时setTag时留下的。&lt;/p&gt;

&lt;p&gt;最终导致此时监听器把用来存储布尔值的线性表的索引1的位置赋值成了item10的值。&lt;/p&gt;

&lt;p&gt;根据问题的成因，我们需要在 onCheckedListener响应前，让view.getTag()获得正确的索引。&lt;/p&gt;

&lt;p&gt;其实很简单只需要将&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;holder.box.setTag(i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;放到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;holder.box.setChecked(isChecked.get(i));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面就可以了。
  此解决方案的完整代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ListAdapter2 extends BaseAdapter {
    ArrayList&amp;lt;String&amp;gt; data;
    ArrayList&amp;lt;Boolean&amp;gt; isChecked;
    Context context;
    Holder holder;
    public ListAdapter2(Context context, ArrayList&amp;lt;String&amp;gt; data, ArrayList&amp;lt;Boolean&amp;gt; isChecked) {
        this.context = context;
        this.data = data;
        this.isChecked = isChecked;
    }

@Override
public int getCount() {
    return data.size();
}

@Override
public Object getItem(int i) {
    return data.get(i);
}

@Override
public long getItemId(int i) {
    return i;
}

@Override
public View getView(int i, View view, ViewGroup viewGroup) {
    if(view == null) {
        view = LayoutInflater.from(context).inflate(R.layout.list_item, null);
        holder = new Holder();
        holder.box = (CheckBox) view.findViewById(R.id.cb_isChecked);
        holder.name = (TextView) view.findViewById(R.id.tv_name);
        view.setTag(holder);

    } else {
        holder = (Holder) view.getTag();
    }

    holder.name.setText(data.get(i));
    System.out.println(&amp;quot;即将改变成&amp;quot; + isChecked.get(i) + &amp;quot;i&amp;quot; + i);
    holder.box.setTag(i);

    holder.box.setChecked(isChecked.get(i));

    holder.box.setOnCheckedChangeListener(new CheckedListener());
    return view;
}

class CheckedListener implements CompoundButton.OnCheckedChangeListener {
    @Override
    public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
        isChecked.set((Integer) compoundButton.getTag(), b);
    }
}

class Holder {
    TextView name;
    CheckBox box;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　
　　&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>