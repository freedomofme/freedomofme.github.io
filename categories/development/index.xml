<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on Coder Yel</title>
    <link>http://freedomofme.github.io/categories/development/</link>
    <description>Recent content in Development on Coder Yel</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Jan 2017 22:25:33 +0800</lastBuildDate>
    <atom:link href="http://freedomofme.github.io/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>多重嵌套布局下滑动冲突解决方案和思路</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%B8%83%E5%B1%80%E4%B8%8B%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Thu, 19 Jan 2017 22:25:33 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%B8%83%E5%B1%80%E4%B8%8B%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E6%80%9D%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>自定义Volley库--HandyVolley</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/HandyVolley/</link>
      <pubDate>Tue, 17 Jan 2017 17:45:23 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/HandyVolley/</guid>
      <description>

&lt;p&gt;本文主要介绍了一个为&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;仿网易新闻APP&lt;/a&gt;的而定制的Volley框架。&lt;/p&gt;

&lt;p&gt;这也是为什么要去修改一个2013年发布的老框架的原因，主要是为了兼容以前的代码。（如果是新上线没有历史负担的项目，网络库(retrofit等)和图片库(glide)等库的性能要更优秀。）&lt;/p&gt;

&lt;h3 id=&#34;一-介绍:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;一、介绍&lt;/h3&gt;

&lt;p&gt;本项目的基于2016年12月29号的原版Volley库开发，也是截止目前的最新版本。从提交日志来看项目代码基于稳定，不会存在重大缺陷。&lt;/p&gt;

&lt;p&gt;目前项目最新版本为1.0.3版本，后期可以会针对做一些微小的优化调整。
本项目兼容原版Volley库的API。&lt;/p&gt;

&lt;p&gt;已经把项目托管于Jcenter仓库，Android项目的话可以用以下语句在Gradle 中引用该项目库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;site.okhttp.codeyel:HandyVolley:1.0.3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第二类-更新细节:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;第二类：更新细节&lt;/h3&gt;

&lt;h5 id=&#34;1-0-0:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.0&lt;/h5&gt;

&lt;p&gt;Fork基于2016年12月29号的原版Volley库&lt;/p&gt;

&lt;h5 id=&#34;1-0-1:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.1&lt;/h5&gt;

&lt;p&gt;更新compileSdkVersion为23&lt;/p&gt;

&lt;h5 id=&#34;1-0-2:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.2&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;增加初始化时的磁盘缓存大小设置&lt;/li&gt;
&lt;li&gt;增加磁盘缓存控制策略：自定义网络响应的Ttl和softTtl。&lt;/li&gt;
&lt;li&gt;增加自定义的缓存设置相对于服务器的缓存策略的优先级控制&lt;/li&gt;
&lt;li&gt;对用户设置不缓存的请求，跳过响应解析操作，微小提升性能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;1-0-3-stable:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.3（Stable）&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;将1.0.2的缓存策略应用于对ImageLoader类&lt;/li&gt;
&lt;li&gt;修复缓存控制Bug&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用样例:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;使用样例&lt;/h3&gt;

&lt;p&gt;经介绍区别于原本Volley的使用方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加初始化时的磁盘缓存大小设置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改方式:Volley.java文件中增加newRequestQueue方法的重载方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxCacheSizeInBytes) 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用方法（其中第三个参数表示瓷片缓存大小为30MB）
    mRequestQueue = Volley.newRequestQueue(mCtx.getApplicationContext(), null, 30 * 1024 * 1024);&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.增加磁盘缓存控制策略：自定义网络响应的Ttl和softTtl&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ttl和softTtl说明
Ttl和softTtl用来用户自定义缓存时间，通常softTtl &amp;lt;= Ttl。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当一个请求的过期时间 &amp;gt; Ttl, 则重新请求服务器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个请求的过期时间 &amp;gt; softTtl &amp;amp;&amp;amp; &amp;lt; Ttl, 则先使用缓存数据做出响应，并同时将该请求发送服务器。（也就是说，响应回调函数会触发两次）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个请求的过期时间 &amp;gt; softTtl，则直接使用本地缓存。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据以上特性，通过设置恰当的Ttl和softTtl，APP可以实现数据的及时展现和刷新。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改细节&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Request.java 增加以下三个属性值和相应的getter：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** this request&#39;s default Soft time limit(unit m       illisecond) if no cache control set by web severs*/
private int mDefaultSoftTtl = 0;


/** this request&#39;s default time limit(unit millisecond) if no cache control set by web severs*/
private int mDefaultTtl = 0;


/**
* Returns true means use the default TTL and soft TTL regardless of the server&#39;s cache control.
* Returns false means server&#39;s cache control has higher priority.
*/
private boolean localCacheControl = false;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;/**
* Returns true if responses to this request should be cached.
*/
public final boolean shouldCache() {
return mShouldCache;
}


/**
* Return this request&#39;s soft time limit (unit seconds).
*/
public int getDefaultSoftTtl() {
  return mDefaultSoftTtl;
}


/**
* Returns this request&#39;s the time limit (unit seconds).
 */
public int getDefaultTtl() {
return mDefaultTtl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中mDefaultSoftTtl表示默认的软缓存时间(单位毫秒)，mDefaultTtl表示默认的缓存时间(单位毫秒)，localCacheControl表示当mDefaultSoftTtl、mDefaultTtl的值和服务器返回的缓存策略冲突时，应该采用哪个数值。（怕大家看不懂我写的蹩脚英文，翻译一下）&lt;/p&gt;

&lt;p&gt;2.同理，在ImageLoader中也增加了以上三个属性和相应的getter。&lt;/p&gt;

&lt;p&gt;方法原型如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
    * Constructs a new ImageLoader.
    * @param queue The RequestQueue to use for making image requests.
    * @param imageCache The cache to use as an L1 cache.
    * @param  defaultSoftTtl this request&#39;s time limit (unit seconds).
    * @param  defaultTtl this request&#39;s soft time limit (unit seconds).
    * @param useLocalCacheControl Returns this request&#39;s cache control priority.
    */
    public ImageLoader(RequestQueue queue, ImageCache imageCache, int defaultSoftTtl, int defaultTtl, boolean useLocalCacheControl) {
        mRequestQueue = queue;
        mCache = imageCache;
        mDefaultSoftTtl = defaultSoftTtl;
        mDefaultTtl = defaultTtl;
        localCacheControl = useLocalCacheControl;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于不经过ImageLoader的Request，如StringRequest，直接覆写Request&lt;T&gt;属性的getter方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new StringRequest(Request.Method.GET, url, responseListener, new DefaultErrorListener(context)) {
    @Override
    public int getDefaultTtl() {
        return 15 * 24 * 3600 * 1000;
    }
    @Override
    public int getDefaultSoftTtl() {
        return 1 * 60 * 1000;
    }
    @Override
    public boolean shouldLocalCacheControl() {
        return true;
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上StringRequest表示默认缓存时间15天，默认软缓存时间1分钟，当与服务器的cache-control冲突时采用此数据为准。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于经过ImageLoader的Request，直接调用ImageLoader的另一个构造方法。&lt;/p&gt;

&lt;p&gt;mImageLoader = new ImageLoader(mRequestQueue, new MyLrnCache(mCtx), 1 * 3600 * 1000, 15 * 24 * 3600 * 1000, true);&lt;/p&gt;

&lt;p&gt;以上ImageLoader表示默认缓存时间15天，默认软缓存时间1小时，当与服务器的cache-control冲突时采用此数据为准。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实际案例&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;Netease&amp;ndash;仿网易新闻Android端APP&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JNI静态与动态注册介绍以及Demo实现</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/demoOfJniRegister/</link>
      <pubDate>Sat, 17 Sep 2016 18:31:12 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/demoOfJniRegister/</guid>
      <description>

&lt;p&gt;一直以来，都觉得Java和Native C的通信没有比较全面直观的教程，知道前几天看见一个大牛的总结。所以接着这个机会，对JNI调用做一些简单记录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JNI的两种注册机制：静态注册和动态注册&lt;/li&gt;
&lt;li&gt;较大型项目JNI的开发框架&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一-jni介绍:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;一、JNI介绍&lt;/h3&gt;

&lt;p&gt;JNI是Java和C进行混合编程的桥梁，其中的核心点就是在Java层声明的Native方法，如何在C层中找到对应的实现。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;静态注册&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;动态注册，需要提供Java中Native方法的方法签名和Native层中对应的实现函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;静态注册:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;静态注册&lt;/h4&gt;

&lt;p&gt;要求C/C++层的函数名符合某种特定的要求:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;包含Java中Native方法的目录信息和方法名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个栗子：
假如以下是StaticTest.java 类代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package jnicourse.hhx.com.jnidemo;

/**
* Created by CodeYel on 16/9/17.
*/
public class StaticTest {
    public native int doAdd(int param1,int param2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这对应的C++中jnicourse_hhx_com_jnidemo_StaticTest.h的函数名是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
* Class:     jnicourse_hhx_com_jnidemo_StaticTest
* Method:    doAdd
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_jnicourse_hhx_com_jnidemo_StaticTest_doAdd (JNIEnv *, jobject, jint, jint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照以上规则进行命名就，在调用到Native的方法时,JVM会去查找是否存在对应函数名的函数，以此实现静态注册。&lt;/p&gt;

&lt;p&gt;附带礼品：NDK提供了javah命令来方便根据.java文件来生成.h。
假如你使用AS作为你的IDE，你可以自定义扩展工具，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;demoOfJniRegister_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;demoOfJniRegister_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用方法：在包含Native声明的方法的文件上右键，选择External Tool中的Javap工具。&lt;/p&gt;

&lt;h4 id=&#34;动态注册:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;动态注册&lt;/h4&gt;

&lt;p&gt;动态注册相对于静态注册，优点是不再根据特定路径查找函数的实现，带来两个好处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;没有了冗杂的函数名，适用于大型项目开发。&lt;/li&gt;
&lt;li&gt;由于不再根据Native函数查找对应的jni层函数，所以首次调用速度比静态注册快。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开发者需要自行提供Java层和C/C++层中的映射关系。&lt;/p&gt;

&lt;p&gt;一种可行的方法是基于JNI重载JNI_OnLoad()，在其中对函数进行动态注册。&lt;/p&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;

&lt;p&gt;DynamicTest.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package jnicourse.hhx.com.jnidemo;

/**
 * Created by CodeYel on 16/9/17.
 */
public class DynamicTest {
    public native int doTwo(int param1, int param2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DynamicBind.cpp&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以下三个部分完成了对方法的动态注册任务。此步骤涉及到如何获取Java函数的问题。具体请查看文末的参考文献，点击此&lt;a href=&#34;http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/&#34;&gt;Link&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static const char *className = &amp;quot;jnicourse/hhx/com/jnidemo/DynamicTest&amp;quot;;


static JNINativeMethod gJni_Methods_DynamicTest[] = {
{&amp;quot;doTwo&amp;quot;, &amp;quot;(II)I&amp;quot;, (void*)addTwoNumber},
};


static int jniRegisterNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods)
{
jclass clazz;


 clazz = (env)-&amp;gt;FindClass( className);
 if (clazz == NULL) {


    return -1;
}
int result = 0;
if ((env)-&amp;gt;RegisterNatives(clazz, gMethods, numMethods) &amp;lt; 0) {


    result = -1;
}
(env)-&amp;gt;DeleteLocalRef(clazz);
return result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重载JNI_OnLoad函数，并在其中调用jniRegisterNativeMethods函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jint JNI_OnLoad(JavaVM* vm, void* reserved){


JNIEnv* env = NULL;
jint result = -1;


if (vm-&amp;gt;GetEnv((void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {
    return result;
}


jniRegisterNativeMethods(env, className, gJni_Methods_DynamicTest, sizeof(gJni_Methods_DynamicTest) / sizeof(JNINativeMethod));


return JNI_VERSION_1_4;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PS：在函数返回值方面，可以做一些定制，来根据返回值判断调用jniRegisterNativeMethods是否成功。&lt;/p&gt;

&lt;h3 id=&#34;二-简单jni开发框架介绍:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;二、简单JNI开发框架介绍&lt;/h3&gt;

&lt;p&gt;结构如下：
&lt;img src=&#34;demoOfJniRegiste_4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;动态注册框架:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;动态注册框架&lt;/h4&gt;

&lt;p&gt;主要由：JniHelper.h和JniHelper.cpp构成。&lt;/p&gt;

&lt;p&gt;是上文介绍的动态注册方法做了一个简单的封装，具体请看DEMO中的DynamicBind2.h和DynamicBind2.cpp文件实现。&lt;/p&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在需要动态注册的文件中，引入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;util/JniHelper.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义一个函数进行注册：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jint register_DT2(JNIEnv * env) {
    return jniRegisterNativeMethods(env, className2, gJni_Methods_DynamicTest2, NELEM(gJni_Methods_DynamicTest2));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在上文的JNI_OnLoad函数进行调用register_DT2函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;log框架:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;Log框架&lt;/h4&gt;

&lt;p&gt;主要由：JniDebug.h和JniDebug.cpp构成。
做了一个简单的实现，具体请看文末贴出的文本DEMO的链接。&lt;/p&gt;

&lt;p&gt;注意在Android.mk文件中添加以下语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;注意事项:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;注意事项&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Android.mk中的添加.cpp文件。&lt;/p&gt;

&lt;p&gt;例如以下代码将dynamic，static，util目录下的cpp文件引入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FILE_LIST := $(wildcard $(LOCAL_PATH)/dynamic/*.cpp) \
$(wildcard $(LOCAL_PATH)/static/*.cpp) \
$(wildcard $(LOCAL_PATH)/util/*.cpp)
LOCAL_SRC_FILES :=$(FILE_LIST:$(LOCAL_PATH)/%=%)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;参考文献:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;参考文献&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;很棒的文章，推荐。另外已经和此文作者进行Email沟通。&lt;a href=&#34;http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/&#34;&gt;http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍了一种使用实验性的Gradle进行开发的方法。&lt;a href=&#34;https://github.com/freekite/Android-JNITest&#34;&gt;https://github.com/freekite/Android-JNITest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一篇比较详细的JNI文章。&lt;a href=&#34;https://my.oschina.net/wolfcs/blog/111309&#34;&gt;https://my.oschina.net/wolfcs/blog/111309&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>仿网易新闻Android端APP实现</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E4%BB%BF%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BBAndroid%E7%AB%AFAPP%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 06 Apr 2016 17:59:59 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E4%BB%BF%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BBAndroid%E7%AB%AFAPP%E5%AE%9E%E7%8E%B0/</guid>
      <description>

&lt;h2 id=&#34;主要功能展示和代码实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;主要功能展示和代码实现&lt;/h2&gt;

&lt;p&gt;2015年10月份左右，差不多花了一周的时间，实现了一个粗略版本。&lt;/p&gt;

&lt;p&gt;截止目前，实现了包括新闻下的包括头条、体育、娱乐的一系列的新闻展示，以及点击后进入的新闻详情展示。&lt;/p&gt;

&lt;h3 id=&#34;目前效果:0e1910fcdf867805caab27c6340158d2&#34;&gt;目前效果&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;目前效果：&lt;img src=&#34;home.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;更新:0e1910fcdf867805caab27c6340158d2&#34;&gt;更新：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2017-01-18 趁着寒假，解决历史遗留的复杂嵌套布局滑动冲突；完成基于&lt;a href=&#34;https://github.com/freedomofme/HandyVolley&#34;&gt;自定义Volley&lt;/a&gt;的内容预加载而后响应网络回调。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2015-XX-XX 新闻内容的详情展示已经实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;技术实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;技术实现&lt;/h2&gt;

&lt;h3 id=&#34;滑动标签:0e1910fcdf867805caab27c6340158d2&#34;&gt;滑动标签&lt;/h3&gt;

&lt;p&gt;APP总体底部的4个Fragment切换和在每个Fragment中的ViewPage切换, 采用的是LuckyJayce/ViewPagerIndicator的开源框架：地址是&lt;a href=&#34;https://github.com/LuckyJayce/ViewPagerIndicator&#34;&gt;ViewPagerIndicator&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然,若是初次接触，建议学习&lt;a href=&#34;https://developer.android.com/samples/SlidingTabsBasic/index.html&#34;&gt;SlidingTabsBasic&lt;/a&gt;,Google官方教程，简洁实现SlidingTab。&lt;/p&gt;

&lt;h3 id=&#34;列表实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;列表实现&lt;/h3&gt;

&lt;p&gt;新闻列表采用纵向RecyclerView，其中暂时划分为3种类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static enum ITEM_TYPE {
    ITEM_TYPE_BANNER,
    ITEM_TYPE_IMAGE,
    ITEM_TYPE_TEXT
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别表示以下3种类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BANNER：
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914143937664-372953191.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;TEXT：
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914143948320-1282950477.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IMAGE：
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914143954336-1896838803.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ITEM_TYPE_BANNER 采用自定义SwitchImage控件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ITEM_TYPE_TEXT 相对布局&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ITEM_TYPE_IMAGE 水平RecycleView （官方版本为三张图片）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;水平列表效果:0e1910fcdf867805caab27c6340158d2&#34;&gt;水平列表效果&lt;/h3&gt;

&lt;p&gt;本部分介绍ITEM_TYPE_IMAGE的水平滑动列表如何实现。
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914144420304-1934370299.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;经过一番努力，现已实现了列表能够响应以下三种情景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;触摸ITEM_TYPE_IMAGE滑动时：
会先根据滑动夹角判断是水平滑动还是上下滑动。

&lt;ul&gt;
&lt;li&gt;如果是水平滑动。滑动时，水平列表滑动。如果水平列表滑动尽头，也不会触发新闻栏目的切换。&lt;/li&gt;
&lt;li&gt;如果是垂直滑动。则相应整个列表的上下滑动。&lt;/li&gt;
&lt;li&gt;如果用户滑动很短距离（很短时间）就抬起手指，则触发点击事件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;水平列表事件冲突处理:0e1910fcdf867805caab27c6340158d2&#34;&gt;水平列表事件冲突处理&lt;/h3&gt;

&lt;h4 id=&#34;1-实现方式:0e1910fcdf867805caab27c6340158d2&#34;&gt;1. 实现方式&lt;/h4&gt;

&lt;p&gt;水平滑动的处理方式一般有ViewPage，Gallery，HorizontalScrollview等几种。&lt;/p&gt;

&lt;p&gt;这里采用在垂直RecycleView中嵌套水平RecycleView。
主要的布局结构是这样的：
&lt;img src=&#34;layout.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-存在问题:0e1910fcdf867805caab27c6340158d2&#34;&gt;2.存在问题&lt;/h4&gt;

&lt;p&gt;如果不进行如何额外的处理，那么看上去一些正常。但是每次将水平列表滑动尽头并继续滑动时，会触发Viewpage的页面切换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;趁着寒假，已经把这个问题分析处理了。&lt;/strong&gt;
&lt;a href=&#34;http://freedomofme.github.io/开发/多重嵌套布局下滑动冲突解决方案和思路&#34;&gt;解决过程和思路完全复盘，值得一看！&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;  但是当我想对水平RecyclerView中的某张图片进行点击时，出现了onClick函数没有回调的问题，由于笔者水平和时间有限，暂时没有深究这个问题。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;于是采用了onTouch函数做点击响应的回调, 做了如下简单的判断：&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt; 用户是点击图片还是水平滑动RecyclerIView &lt;/del&gt;
&lt;del&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;imageView.setOnTouchListener(new View.OnTouchListener() {
  @Override
 public boolean onTouch(View v, MotionEvent event) {
  //抬起按钮时判断，之前是否滑动了,若没有滑动则响应点击事件
                if (event.getAction() == MotionEvent.ACTION_UP &amp;amp;&amp;amp; !isMoved)
                    mListener.onViewPageTouch((NetworkImageView) v, index);
                else {
                    isMoved = false;
                }
                if (event.getAction() == MotionEvent.ACTION_MOVE) {
                    isMoved = true;
                }
                return true;
            }
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;基于自定义volley预加载和回调刷新:0e1910fcdf867805caab27c6340158d2&#34;&gt;基于自定义Volley预加载和回调刷新&lt;/h3&gt;

&lt;h4 id=&#34;目前效果-1:0e1910fcdf867805caab27c6340158d2&#34;&gt;目前效果&lt;/h4&gt;

&lt;p&gt;首次打开APP时，先显示缓存内容，然后同时请求网络，显示最新内容。&lt;/p&gt;

&lt;h4 id=&#34;最简单的实现方案:0e1910fcdf867805caab27c6340158d2&#34;&gt;最简单的实现方案&lt;/h4&gt;

&lt;p&gt;一般的话，可能会使用数据库之类的存储结构来保存历史新闻。但是，我想简化这个过程，依赖于网络请求框架的缓存来实现。&lt;/p&gt;

&lt;p&gt;一开始想的是给修改Volley源码，为Response.Listener(T response)接口增加一个回调方法onCacheHit(T response)方案,如以下代码所示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public interface Listener&amp;lt;T&amp;gt; {
    /** Called when a response is received. */
    public void onResponse(T response);
    /** 存在缓存 */
    public void onCacheHit(T response);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，经过阅读Volley的源码，发现可以通过修改一个Response的softTTL和TTL来实现以上想法。&lt;/p&gt;

&lt;p&gt;于是根据这个想法，修改出了一个HandyVolley的框架，使用文档见于此处&amp;ndash;&lt;a href=&#34;https://github.com/freedomofme/HandyVolley&#34;&gt;HandyVolley&lt;/a&gt;，并发布于Jcente仓库中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;site.okhttp.codeyel:HandyVolley:1.0.3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;顶部沉浸式状态栏实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;顶部沉浸式状态栏实现&lt;/h3&gt;

&lt;p&gt;参考了这篇文章：
&lt;a href=&#34;http://www.jianshu.com/p/f8374d6267ef&#34;&gt;http://www.jianshu.com/p/f8374d6267ef&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;新闻详情实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;新闻详情实现&lt;/h3&gt;

&lt;p&gt;首先，根据网络返回的数据的样式确定解析方案：&lt;/p&gt;

&lt;p&gt;NewsDisplayActivity.java第70行，展示了一个返回数据Html格式的样例：&lt;a href=&#34;https://github.com/freedomofme/Netease/commit/bb6db85de547d4d5243e17e881bc2116122e52d6&#34;&gt;https://github.com/freedomofme/Netease/commit/bb6db85de547d4d5243e17e881bc2116122e52d6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文采用的方法是通过Android自带的android.text.Html类解析Html和html下&lt;img&gt;标签的图像。
核心代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    URLImageParser p = new URLImageParser(content, this);
    Spanned htmlSpan = Html.fromHtml(body, p, null);
    content.setText(htmlSpan);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的URLImageParser是用来解析&lt;img&gt;标签的，这里有很大的进一步优化的空间。&lt;/p&gt;

&lt;p&gt;这类主要是参考该文，并修正了图片尺寸上的问题。&lt;a href=&#34;http://stackoverflow.com/questions/15617210/android-html-fromhtml-with-images/15617341#15617341&#34;&gt;http://stackoverflow.com/questions/15617210/android-html-fromhtml-with-images/15617341#15617341&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，除了用TextView来展示Html（在Android
中就是Spanned类），也可以使用WebView。
两者的主要区别：
* WebView：加载HTML更为方便（笔者觉得），支持的标签更多，与APP交互需要通过JS接口
* TextView： 除了文本显示，对于其他很多交互行为，需要重写函数。开发者对展示细节的控制能力更强。
详细内容可以参考:&lt;a href=&#34;https://www.ibm.com/developerworks/cn/web/1407_zhangqian_androidhtml/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;数据请求与相应:0e1910fcdf867805caab27c6340158d2&#34;&gt;数据请求与相应&lt;/h3&gt;

&lt;p&gt;采用的是Volley框架，并封装了RequestSingletonFactory工厂类来方便请求。
URLs类中采用反射的方式来读取静态URL的数据。&lt;/p&gt;

&lt;h3 id=&#34;接下来:0e1910fcdf867805caab27c6340158d2&#34;&gt;接下来&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;完善新闻阅读的排版，对于部分网页存在数据不兼容，导致解析的Bug&lt;/li&gt;
&lt;li&gt;增加查看新闻评论功能&lt;/li&gt;
&lt;li&gt;增加用户设置界面&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;下载地址:0e1910fcdf867805caab27c6340158d2&#34;&gt;下载地址&lt;/h3&gt;

&lt;p&gt;本项目将在持续更新，更加完善，项目源码地址：
&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;https://github.com/freedomofme/Netease&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本开源项目仅供学习，不得作为其他用途&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>http://freedomofme.github.io/aboutme/</link>
      <pubDate>Fri, 01 Apr 2016 15:21:43 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/aboutme/</guid>
      <description>&lt;p&gt;你好，我叫Coder Yel，中山大学数据科学学院的研究生一枚，很高兴你的到来，本站关注于一些小众的Java和Android知识的介绍和汇总。&lt;/p&gt;

&lt;p&gt;2016.4.6 完成的博客文章迁移~&lt;/p&gt;

&lt;p&gt;我的邮箱: &lt;a href=&#34;mailto:huanghanxiongchn@gmail.com&#34;&gt;huanghanxiongchn@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的Git: &lt;a href=&#34;https://github.com/freedomofme&#34;&gt;https://github.com/freedomofme&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>