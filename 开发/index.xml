<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发s on Coder Yel</title>
    <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 开发s on Coder Yel</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Jan 2017 22:25:33 +0800</lastBuildDate>
    <atom:link href="http://freedomofme.github.io/%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>多重嵌套布局下滑动冲突解决方案和思路</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%B8%83%E5%B1%80%E4%B8%8B%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Thu, 19 Jan 2017 22:25:33 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%B8%83%E5%B1%80%E4%B8%8B%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E6%80%9D%E8%B7%AF/</guid>
      <description>

&lt;h3 id=&#34;前言:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;本文主要介绍在开发&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;仿网易新闻客户端&lt;/a&gt;遇到的多层控件滑动冲突问题，以及如何控制事件传递的方法和解决问题的过程。&lt;/p&gt;

&lt;h3 id=&#34;问题复现:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;问题复现&lt;/h3&gt;

&lt;h4 id=&#34;一-局部:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;一、局部&lt;/h4&gt;

&lt;p&gt;以下是界面布局的简图，问题分析将根据以下展开。
一共有三层：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;最外层是一个Viewpager，如图所示在Viewpager中有两个页面，分别是“博客”和“旅游”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;中间层垂直的RecyclerView。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最内层是水平的RecyclerView。为了方便下文介绍，命名为MyRecyclerView。在其中，有一系列的item，将item命名为ImageViewHolder，并为其增加点击事件(OnClickListener)。如下图蓝色方块所示。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;layout.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;二-问题代码:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;二、问题代码：&lt;/h4&gt;

&lt;p&gt;item_image.xml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;com.hhxplaying.neteasedemo.netease.widget.HorizontalRecyclerView
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;@dimen/list_big_image_item_height&amp;quot;
    android:id=&amp;quot;@+id/rv_subrecycleview&amp;quot;
    android:layout_below=&amp;quot;@+id/tv_title&amp;quot;
    android:layout_centerVertical=&amp;quot;true&amp;quot;
    android:layout_centerHorizontal=&amp;quot;true&amp;quot;
    /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HorizontalRecyclerView.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class HorizontalRecyclerView extends RecyclerView {
public HorizontalRecyclerView(Context context, AttributeSet attrs) {
    super(context, attrs);
}

public HorizontalRecyclerView(Context context) {
    super(context);
}

public HorizontalRecyclerView(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
}

@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    Log.d(&amp;quot;HorizontalImage&amp;quot;, &amp;quot;parent onIntercept &amp;quot; + event);
    boolean b = super.onInterceptTouchEvent(event);
    Log.d(&amp;quot;HorizontalImage&amp;quot;, &amp;quot;parent onIntercept &amp;quot; + b);
    return b;
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    boolean t =  super.onTouchEvent(event);
    Log.d(&amp;quot;HorizontalRecyclerView&amp;quot;, &amp;quot;parent onTouchEvent &amp;quot; + t);
    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HorizontalImageRecyclerViewAdapter.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ImageViewHolder holder = new ImageViewHolder();
holder.imageView.setOnClickListener(this);          
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;三-情境描述:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;三、情境描述：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正常情景：&lt;strong&gt;滑动水平列表HorizontalRecyclerView时，如果一开始滑动时，列表是有滑动的空间的。那么子控件会消费事件使得后续事件一直传递，即使当列表最后滑动到尽头后继续滑动，事件也会继续传递给水平滑动控件，所以外部的viewpage不会响应。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;问题情景：&lt;strong&gt;滑动水平列表/HorizontalRecyclerView时，如果一开始滑动时，列表是没有滑动的空间的，即已经到达尽头。此时外部的Viewpager首先向内传递事件，但是事件无法被内部控件消费（水平列表无法滑动，同时也不满足触发内部点击事件的要求），所以最终触发Viewpager（虽然事件最后还是会被HorizontalRecyclerView拦截和消费）。所以，此时用户滑动改水平列表时，外部的viewpage会滑动。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上两种情况的log基本相同（不同的是正常情况下onTouch会一直调用），一开始是false的原因是水平列表的item的内部设置了OnClickListen，有可能触发。所以滑动了一段距离后，不可能再触发click，所以返回true。 Log如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D/HorizontalRecyclerView: parent onIntercept MotionEvent { action=ACTION_MOVE
D/HorizontalRecyclerView: parent onIntercept false                           
D/HorizontalRecyclerView: parent onIntercept MotionEvent { action=ACTION_MOVE
D/HorizontalRecyclerView: parent onIntercept false                           
D/HorizontalRecyclerView: parent onIntercept MotionEvent { action=ACTION_MOVE
D/HorizontalRecyclerView: parent onIntercept false                           
D/HorizontalRecyclerView: parent onIntercept MotionEvent { action=ACTION_MOVE
D/HorizontalRecyclerView: parent onIntercept false                           
D/HorizontalRecyclerView: parent onIntercept MotionEvent { action=ACTION_MOVE
D/HorizontalRecyclerView: parent onIntercept true                            
D/HorizontalRecyclerView: parent onTouchEvent true                           
D/HorizontalRecyclerView: parent onTouchEvent true                            
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换而言之，如果去掉holder.imageView.setOnClickListener(this)，那么只会调用一次onIntercept并返回false，而后onTouchEvent会在第一时间触发。Log如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D/HorizontalRecyclerView: parent onIntercept MotionEvent { action=ACTION_DOWN
D/HorizontalRecyclerView: parent onIntercept false                           
D/HorizontalRecyclerView: parent onTouchEvent true                           
D/HorizontalRecyclerView: parent onTouchEvent true                           
D/HorizontalRecyclerView: parent onTouchEvent true                                                                                                 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，如果去掉内部点击事件的话，这个问题处理会简单很多。但是在这里，我们需要内部item响应点击事件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当HorizontalRecyclerView到尽头时，此时用户水平滑动会导致Viewpager的切换。造成用户的不方便，需要改善。在这种情况下，理想的交互应该是Viewpager不响应此时的水平滑动。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;解决思路:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;解决思路&lt;/h3&gt;

&lt;h4 id=&#34;第一次尝试解决:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;第一次尝试解决：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;思路：当水平列表滑动时，使得Viewpager不再响应水平滑动。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码： HorizontalRecyclerView.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public boolean onTouchEvent(MotionEvent event) {
switch (event.getAction()) {
    case MotionEvent.ACTION_MOVE:
        getParent().requestDisallowInterceptTouchEvent(true);
        break;
    case MotionEvent.ACTION_UP:
    case MotionEvent.ACTION_CANCEL:
        getParent().requestDisallowInterceptTouchEvent(false);
        break;
}
boolean t =  super.onTouchEvent(event);
Log.d(&amp;quot;HorizontalRecyclerView&amp;quot;, &amp;quot;parent onTouchEvent &amp;quot; + t);
return t;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;效果：当ImageViewHolder设置了OnClickListner时，用户慢速滑动HorizontalRecyclerView时，viewpager不会响应，快速滑动时viewpager还是会响应；当ImageViewHolder没有设置了OnClickListner时，用户快速滑动viewpager也不会响应。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么内部item是否设置了OnClickListner会影响快速滑动的表现，原因在于HorizontalRecyclerView中的onTouchEvent的语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getParent().requestDisallowInterceptTouchEvent(true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;能否及时调用。如果调用晚了，viewpagr已经有了偏移则此语句不会产生效果。&lt;/p&gt;

&lt;h4 id=&#34;第二次尝试解决:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;第二次尝试解决：&lt;/h4&gt;

&lt;p&gt;以上代码有一个问题：用户快速滑动HorizontalRecyclerView的结果不理想（内部设置点击事件），还是和原来一样。 原因上文已经说明了HorizontalRecyclerView 中的onTouchEvent方法调用不及时。&lt;/p&gt;

&lt;p&gt;针对这个不及时的问题：考虑在HorizontalRecyclerView的onInterceptTouchEvent进行拦截。代码如下：即用户按下时就阻止外部控件响应。&lt;/p&gt;

&lt;p&gt;HorizontalRecyclerView.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            getParent().requestDisallowInterceptTouchEvent(true);
            firstTime = true;
            x = event.getX();
            y = event.getY();
            break;
    }

    return super.onInterceptTouchEvent(event);;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当时经过测试，发现增加以上代码后，会导致无法通过竖直滑动外部的垂直RecyclerView。因为统统都被getParent().requestDisallowInterceptTouchEvent(true)拦截了（可以查看这个方法的源代码，会一直向上递归调用）。&lt;/p&gt;

&lt;p&gt;所以，我们希望当判断不能出再出发点击事件时，应该不再拦截外部空间响应垂直滑动的事件。
其中isIntercept变量是来自与水平列表中的Item的onTouch方法中，检测该事件能否发生点击（判断时间和滑动距离）。如果能则变量为false。如果不能满足点击事件则为true，表示外部应该拦截后续事件。&lt;/p&gt;

&lt;p&gt;HorizontalRecyclerView.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    boolean temp = super.onInterceptTouchEvent(event);
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            getParent().requestDisallowInterceptTouchEvent(true);
            firstTime = true;
            x = event.getX();
            y = event.getY();
            break;
    }

    boolean isIntercept = ((HorizontalImageRecyclerViewAdapter)getAdapter()).isIntercept;

    Log.d(&amp;quot;HorizontalImage&amp;quot;, &amp;quot;parent onIntercept isIntercept:&amp;quot; + isIntercept);

    return temp || isIntercept;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;最后方案:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;最后方案：&lt;/h4&gt;

&lt;p&gt;根据以上的尝试，我们现在理一下思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;思路：
用户刚点击时，点击事件会到达对内层的水平列表的item，经过判断是否能触发点击事件，并设置标志位isIntercept。如果不能触发，则在外部onInterceptTouchEvent方法中根据标志位isIntercept进行拦截。使得调用外部HorizontalRecyclerView的onTouch方法，并在该方法中判断用户是水平滑动还是竖直滑动。如果是水平滑动着调用getParent().requestDisallowInterceptTouchEvent(true)，如果是竖直滑动不处理。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;疑问：内部item的点击事件为什么不用onClick而使用onTouch？
因为假如使用onClick则无法灵活的对各种MotionEvent进行判断。（当然也可以同时混合使用，onTouch处理拦截标志位，onClick处理点击。只要onTouch方法返回false即可）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码片段1: 在内部item的onTouch中判断能否触发点击事件。
关键代码是比较初始点位置和当前点位置的距离是否超过阈值。（viewConfiguration.getScaledTouchSlop()）以及 从按下到抬起的时间差是否小于ViewConfiguration.getJumpTapTimeout()。&lt;a href=&#34;#end&#34;&gt;详细介绍请见文末&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean onTouch(View v, MotionEvent event) {


long pressDuration = System.currentTimeMillis() - pressStartTime;


switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        pressStartTime = System.currentTimeMillis();
        pressedX = event.getX();
        pressedY = event.getY();
        isIntercept = false;
        break;
    }
    case MotionEvent.ACTION_MOVE:
        if (pressDuration &amp;lt;= ViewConfiguration.getJumpTapTimeout()
                &amp;amp;&amp;amp; distance(pressedX, pressedY, event.getX(), event.getY()) &amp;lt;= viewConfiguration.getScaledTouchSlop()) {
        } else {
            //此标志位相当重要，不能用requestDisallowInterceptTouchEvent()方法代替.
            //@link https://developer.android.com/guide/topics/ui/ui-events.html#TouchMode
            // 也可根据ViewGroup.java的onInterceptTouchEvent()源码查看这个方法逻辑。
            isIntercept = true;
        }
        break;
    case MotionEvent.ACTION_UP: {
        if (pressDuration &amp;lt;= ViewConfiguration.getJumpTapTimeout()
                &amp;amp;&amp;amp; distance(pressedX, pressedY, event.getX(), event.getY()) &amp;lt;= viewConfiguration.getScaledTouchSlop()) {
            //doSomething()
        } else {
            isIntercept = true;
        }
        break;
    }
}


return true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码片段2: 判断是水平滑动还是竖直滑动。
思路是比较水平滑动距离和竖直滑动距离的大小来判断。firstTime表示本次事件认定为水平滑动或者竖直滑动后不再变更判断结果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public boolean onTouchEvent(MotionEvent event) {
switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN:
        getParent().requestDisallowInterceptTouchEvent(true);
        firstTime = true;
        x = event.getX();
        y = event.getY();
        break;
    case MotionEvent.ACTION_MOVE:
        if (firstTime) {
            float deltaX = Math.abs(x - event.getX());
            float deltaY = Math.abs(y - event.getY());


            if (deltaX &amp;gt; 1 || deltaY &amp;gt; 1) {
                // 水平滑动距离大于两倍的垂直距离才判断为水平
                if (deltaX &amp;gt; deltaY * 2) {
                    getParent().requestDisallowInterceptTouchEvent(true);
                } else {
                    getParent().requestDisallowInterceptTouchEvent(false);
                }
                firstTime = false;
            }
        }
        break;
    case MotionEvent.ACTION_CANCEL:
    case MotionEvent.ACTION_UP:
    case MotionEvent.ACTION_OUTSIDE:
        getParent().requestDisallowInterceptTouchEvent(false);
     ((HorizontalImageRecyclerViewAdapter)getAdapter()).isIntercept = false;
        break;
}
return super.onTouchEvent(event);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;最终代码:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;最终代码&lt;/h3&gt;

&lt;p&gt;见项目的&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;https://github.com/freedomofme/Netease&lt;/a&gt;
的&lt;a href=&#34;https://github.com/freedomofme/Netease/blob/master/app/src/main/java/com/hhxplaying/neteasedemo/netease/widget/MyRecyclerView.java&#34;&gt;HorizontalRecyclerView.java&lt;/a&gt;和&lt;a href=&#34;https://github.com/freedomofme/Netease/blob/master/app/src/main/java/com/hhxplaying/neteasedemo/netease/adapter/HorizontalImageRecyclerViewAdapter.java&#34;&gt;HorizontalImageRecyclerViewAdapter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文本记录了这个问题探索的正确轨迹，没有记录在实际开发中所走的弯路。写的不正确和含糊不清之处，还望斧正。&lt;/p&gt;

&lt;h3 id=&#34;附录:fd48b6ffc67f79575873dd093c0eda1d&#34;&gt;附录&lt;/h3&gt;

&lt;p&gt;&lt;a name=&#34;end&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ViewConfiguration.java&lt;/p&gt;

&lt;p&gt;点击时间间隔&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; /**
 * Defines the duration in milliseconds we will wait to see if a touch event * is a tap or a scroll. If the user does not move within this interval, it is * considered to be a tap.
 */
private static final int TAP_TIMEOUT = 100;
/**
 * Defines the duration in milliseconds we will wait to see if a touch event * is a jump tap. If the user does not complete the jump tap within this interval, it is * considered to be a tap.
 */
private static final int JUMP_TAP_TIMEOUT = 500;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点击距离间隔&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @return Distance in dips a touch can wander before we think the user is scrolling * * @deprecated Use {@link #getScaledTouchSlop()} instead.
 */
@Deprecated
public static int getTouchSlop() {
    return TOUCH_SLOP;
} 

//这是默认值 8dp。 
private static final int TOUCH_SLOP = 8; 

/** * @return Distance in pixels a touch can wander before we think the user is scrolling */ 
public int getScaledTouchSlop() { return mTouchSlop; }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>自定义Volley库--HandyVolley</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/HandyVolley/</link>
      <pubDate>Tue, 17 Jan 2017 17:45:23 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/HandyVolley/</guid>
      <description>

&lt;p&gt;本文主要介绍了一个为&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;仿网易新闻APP&lt;/a&gt;的而定制的Volley框架。&lt;/p&gt;

&lt;p&gt;这也是为什么要去修改一个2013年发布的老框架的原因，主要是为了兼容以前的代码。（如果是新上线没有历史负担的项目，网络库(retrofit等)和图片库(glide)等库的性能要更优秀。）&lt;/p&gt;

&lt;h3 id=&#34;一-介绍:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;一、介绍&lt;/h3&gt;

&lt;p&gt;本项目的基于2016年12月29号的原版Volley库开发，也是截止目前的最新版本。从提交日志来看项目代码基于稳定，不会存在重大缺陷。&lt;/p&gt;

&lt;p&gt;目前项目最新版本为1.0.3版本，后期可以会针对做一些微小的优化调整。
本项目兼容原版Volley库的API。&lt;/p&gt;

&lt;p&gt;已经把项目托管于Jcenter仓库，Android项目的话可以用以下语句在Gradle 中引用该项目库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;site.okhttp.codeyel:HandyVolley:1.0.3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第二类-更新细节:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;第二类：更新细节&lt;/h3&gt;

&lt;h5 id=&#34;1-0-0:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.0&lt;/h5&gt;

&lt;p&gt;Fork基于2016年12月29号的原版Volley库&lt;/p&gt;

&lt;h5 id=&#34;1-0-1:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.1&lt;/h5&gt;

&lt;p&gt;更新compileSdkVersion为23&lt;/p&gt;

&lt;h5 id=&#34;1-0-2:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.2&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;增加初始化时的磁盘缓存大小设置&lt;/li&gt;
&lt;li&gt;增加磁盘缓存控制策略：自定义网络响应的Ttl和softTtl。&lt;/li&gt;
&lt;li&gt;增加自定义的缓存设置相对于服务器的缓存策略的优先级控制&lt;/li&gt;
&lt;li&gt;对用户设置不缓存的请求，跳过响应解析操作，微小提升性能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;1-0-3-stable:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;1.0.3（Stable）&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;将1.0.2的缓存策略应用于对ImageLoader类&lt;/li&gt;
&lt;li&gt;修复缓存控制Bug&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用样例:c8ec1fc3ec01d9d6630de439b81fa1a7&#34;&gt;使用样例&lt;/h3&gt;

&lt;p&gt;经介绍区别于原本Volley的使用方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加初始化时的磁盘缓存大小设置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改方式:Volley.java文件中增加newRequestQueue方法的重载方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxCacheSizeInBytes) 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用方法（其中第三个参数表示瓷片缓存大小为30MB）
    mRequestQueue = Volley.newRequestQueue(mCtx.getApplicationContext(), null, 30 * 1024 * 1024);&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.增加磁盘缓存控制策略：自定义网络响应的Ttl和softTtl&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ttl和softTtl说明
Ttl和softTtl用来用户自定义缓存时间，通常softTtl &amp;lt;= Ttl。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当一个请求的过期时间 &amp;gt; Ttl, 则重新请求服务器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个请求的过期时间 &amp;gt; softTtl &amp;amp;&amp;amp; &amp;lt; Ttl, 则先使用缓存数据做出响应，并同时将该请求发送服务器。（也就是说，响应回调函数会触发两次）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个请求的过期时间 &amp;gt; softTtl，则直接使用本地缓存。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据以上特性，通过设置恰当的Ttl和softTtl，APP可以实现数据的及时展现和刷新。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改细节&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Request.java 增加以下三个属性值和相应的getter：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** this request&#39;s default Soft time limit(unit m       illisecond) if no cache control set by web severs*/
private int mDefaultSoftTtl = 0;


/** this request&#39;s default time limit(unit millisecond) if no cache control set by web severs*/
private int mDefaultTtl = 0;


/**
* Returns true means use the default TTL and soft TTL regardless of the server&#39;s cache control.
* Returns false means server&#39;s cache control has higher priority.
*/
private boolean localCacheControl = false;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;/**
* Returns true if responses to this request should be cached.
*/
public final boolean shouldCache() {
return mShouldCache;
}


/**
* Return this request&#39;s soft time limit (unit seconds).
*/
public int getDefaultSoftTtl() {
  return mDefaultSoftTtl;
}


/**
* Returns this request&#39;s the time limit (unit seconds).
 */
public int getDefaultTtl() {
return mDefaultTtl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中mDefaultSoftTtl表示默认的软缓存时间(单位毫秒)，mDefaultTtl表示默认的缓存时间(单位毫秒)，localCacheControl表示当mDefaultSoftTtl、mDefaultTtl的值和服务器返回的缓存策略冲突时，应该采用哪个数值。（怕大家看不懂我写的蹩脚英文，翻译一下）&lt;/p&gt;

&lt;p&gt;2.同理，在ImageLoader中也增加了以上三个属性和相应的getter。&lt;/p&gt;

&lt;p&gt;方法原型如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
    * Constructs a new ImageLoader.
    * @param queue The RequestQueue to use for making image requests.
    * @param imageCache The cache to use as an L1 cache.
    * @param  defaultSoftTtl this request&#39;s time limit (unit seconds).
    * @param  defaultTtl this request&#39;s soft time limit (unit seconds).
    * @param useLocalCacheControl Returns this request&#39;s cache control priority.
    */
    public ImageLoader(RequestQueue queue, ImageCache imageCache, int defaultSoftTtl, int defaultTtl, boolean useLocalCacheControl) {
        mRequestQueue = queue;
        mCache = imageCache;
        mDefaultSoftTtl = defaultSoftTtl;
        mDefaultTtl = defaultTtl;
        localCacheControl = useLocalCacheControl;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于不经过ImageLoader的Request，如StringRequest，直接覆写Request&lt;T&gt;属性的getter方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new StringRequest(Request.Method.GET, url, responseListener, new DefaultErrorListener(context)) {
    @Override
    public int getDefaultTtl() {
        return 15 * 24 * 3600 * 1000;
    }
    @Override
    public int getDefaultSoftTtl() {
        return 1 * 60 * 1000;
    }
    @Override
    public boolean shouldLocalCacheControl() {
        return true;
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上StringRequest表示默认缓存时间15天，默认软缓存时间1分钟，当与服务器的cache-control冲突时采用此数据为准。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于经过ImageLoader的Request，直接调用ImageLoader的另一个构造方法。&lt;/p&gt;

&lt;p&gt;mImageLoader = new ImageLoader(mRequestQueue, new MyLrnCache(mCtx), 1 * 3600 * 1000, 15 * 24 * 3600 * 1000, true);&lt;/p&gt;

&lt;p&gt;以上ImageLoader表示默认缓存时间15天，默认软缓存时间1小时，当与服务器的cache-control冲突时采用此数据为准。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实际案例&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;Netease&amp;ndash;仿网易新闻Android端APP&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JNI静态与动态注册介绍以及Demo实现</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/demoOfJniRegister/</link>
      <pubDate>Sat, 17 Sep 2016 18:31:12 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/demoOfJniRegister/</guid>
      <description>

&lt;p&gt;一直以来，都觉得Java和Native C的通信没有比较全面直观的教程，知道前几天看见一个大牛的总结。所以接着这个机会，对JNI调用做一些简单记录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JNI的两种注册机制：静态注册和动态注册&lt;/li&gt;
&lt;li&gt;较大型项目JNI的开发框架&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一-jni介绍:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;一、JNI介绍&lt;/h3&gt;

&lt;p&gt;JNI是Java和C进行混合编程的桥梁，其中的核心点就是在Java层声明的Native方法，如何在C层中找到对应的实现。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;静态注册&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;动态注册，需要提供Java中Native方法的方法签名和Native层中对应的实现函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;静态注册:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;静态注册&lt;/h4&gt;

&lt;p&gt;要求C/C++层的函数名符合某种特定的要求:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;包含Java中Native方法的目录信息和方法名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个栗子：
假如以下是StaticTest.java 类代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package jnicourse.hhx.com.jnidemo;

/**
* Created by CodeYel on 16/9/17.
*/
public class StaticTest {
    public native int doAdd(int param1,int param2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这对应的C++中jnicourse_hhx_com_jnidemo_StaticTest.h的函数名是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
* Class:     jnicourse_hhx_com_jnidemo_StaticTest
* Method:    doAdd
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_jnicourse_hhx_com_jnidemo_StaticTest_doAdd (JNIEnv *, jobject, jint, jint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照以上规则进行命名就，在调用到Native的方法时,JVM会去查找是否存在对应函数名的函数，以此实现静态注册。&lt;/p&gt;

&lt;p&gt;附带礼品：NDK提供了javah命令来方便根据.java文件来生成.h。
假如你使用AS作为你的IDE，你可以自定义扩展工具，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;demoOfJniRegister_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;demoOfJniRegister_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用方法：在包含Native声明的方法的文件上右键，选择External Tool中的Javap工具。&lt;/p&gt;

&lt;h4 id=&#34;动态注册:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;动态注册&lt;/h4&gt;

&lt;p&gt;动态注册相对于静态注册，优点是不再根据特定路径查找函数的实现，带来两个好处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;没有了冗杂的函数名，适用于大型项目开发。&lt;/li&gt;
&lt;li&gt;由于不再根据Native函数查找对应的jni层函数，所以首次调用速度比静态注册快。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开发者需要自行提供Java层和C/C++层中的映射关系。&lt;/p&gt;

&lt;p&gt;一种可行的方法是基于JNI重载JNI_OnLoad()，在其中对函数进行动态注册。&lt;/p&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;

&lt;p&gt;DynamicTest.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package jnicourse.hhx.com.jnidemo;

/**
 * Created by CodeYel on 16/9/17.
 */
public class DynamicTest {
    public native int doTwo(int param1, int param2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DynamicBind.cpp&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以下三个部分完成了对方法的动态注册任务。此步骤涉及到如何获取Java函数的问题。具体请查看文末的参考文献，点击此&lt;a href=&#34;http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/&#34;&gt;Link&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static const char *className = &amp;quot;jnicourse/hhx/com/jnidemo/DynamicTest&amp;quot;;


static JNINativeMethod gJni_Methods_DynamicTest[] = {
{&amp;quot;doTwo&amp;quot;, &amp;quot;(II)I&amp;quot;, (void*)addTwoNumber},
};


static int jniRegisterNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods)
{
jclass clazz;


 clazz = (env)-&amp;gt;FindClass( className);
 if (clazz == NULL) {


    return -1;
}
int result = 0;
if ((env)-&amp;gt;RegisterNatives(clazz, gMethods, numMethods) &amp;lt; 0) {


    result = -1;
}
(env)-&amp;gt;DeleteLocalRef(clazz);
return result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重载JNI_OnLoad函数，并在其中调用jniRegisterNativeMethods函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jint JNI_OnLoad(JavaVM* vm, void* reserved){


JNIEnv* env = NULL;
jint result = -1;


if (vm-&amp;gt;GetEnv((void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {
    return result;
}


jniRegisterNativeMethods(env, className, gJni_Methods_DynamicTest, sizeof(gJni_Methods_DynamicTest) / sizeof(JNINativeMethod));


return JNI_VERSION_1_4;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PS：在函数返回值方面，可以做一些定制，来根据返回值判断调用jniRegisterNativeMethods是否成功。&lt;/p&gt;

&lt;h3 id=&#34;二-简单jni开发框架介绍:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;二、简单JNI开发框架介绍&lt;/h3&gt;

&lt;p&gt;结构如下：
&lt;img src=&#34;demoOfJniRegiste_4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;动态注册框架:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;动态注册框架&lt;/h4&gt;

&lt;p&gt;主要由：JniHelper.h和JniHelper.cpp构成。&lt;/p&gt;

&lt;p&gt;是上文介绍的动态注册方法做了一个简单的封装，具体请看DEMO中的DynamicBind2.h和DynamicBind2.cpp文件实现。&lt;/p&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在需要动态注册的文件中，引入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;util/JniHelper.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义一个函数进行注册：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jint register_DT2(JNIEnv * env) {
    return jniRegisterNativeMethods(env, className2, gJni_Methods_DynamicTest2, NELEM(gJni_Methods_DynamicTest2));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在上文的JNI_OnLoad函数进行调用register_DT2函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;log框架:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;Log框架&lt;/h4&gt;

&lt;p&gt;主要由：JniDebug.h和JniDebug.cpp构成。
做了一个简单的实现，具体请看文末贴出的文本DEMO的链接。&lt;/p&gt;

&lt;p&gt;注意在Android.mk文件中添加以下语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;注意事项:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;注意事项&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Android.mk中的添加.cpp文件。&lt;/p&gt;

&lt;p&gt;例如以下代码将dynamic，static，util目录下的cpp文件引入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FILE_LIST := $(wildcard $(LOCAL_PATH)/dynamic/*.cpp) \
$(wildcard $(LOCAL_PATH)/static/*.cpp) \
$(wildcard $(LOCAL_PATH)/util/*.cpp)
LOCAL_SRC_FILES :=$(FILE_LIST:$(LOCAL_PATH)/%=%)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;参考文献:2848143d4f7cd8cc66ecf3924bd7d3e0&#34;&gt;参考文献&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;很棒的文章，推荐。另外已经和此文作者进行Email沟通。&lt;a href=&#34;http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/&#34;&gt;http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍了一种使用实验性的Gradle进行开发的方法。&lt;a href=&#34;https://github.com/freekite/Android-JNITest&#34;&gt;https://github.com/freekite/Android-JNITest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一篇比较详细的JNI文章。&lt;a href=&#34;https://my.oschina.net/wolfcs/blog/111309&#34;&gt;https://my.oschina.net/wolfcs/blog/111309&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>仿网易新闻Android端APP实现</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E4%BB%BF%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BBAndroid%E7%AB%AFAPP%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 06 Apr 2016 17:59:59 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E4%BB%BF%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BBAndroid%E7%AB%AFAPP%E5%AE%9E%E7%8E%B0/</guid>
      <description>

&lt;h2 id=&#34;主要功能展示和代码实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;主要功能展示和代码实现&lt;/h2&gt;

&lt;p&gt;2015年10月份左右，差不多花了一周的时间，实现了一个粗略版本。&lt;/p&gt;

&lt;p&gt;截止目前，实现了包括新闻下的包括头条、体育、娱乐的一系列的新闻展示，以及点击后进入的新闻详情展示。&lt;/p&gt;

&lt;h3 id=&#34;目前效果:0e1910fcdf867805caab27c6340158d2&#34;&gt;目前效果&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;目前效果：&lt;img src=&#34;home.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;更新:0e1910fcdf867805caab27c6340158d2&#34;&gt;更新：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2017-01-18 趁着寒假，解决历史遗留的复杂嵌套布局滑动冲突；完成基于&lt;a href=&#34;https://github.com/freedomofme/HandyVolley&#34;&gt;自定义Volley&lt;/a&gt;的内容预加载而后响应网络回调。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2015-XX-XX 新闻内容的详情展示已经实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;技术实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;技术实现&lt;/h2&gt;

&lt;h3 id=&#34;滑动标签:0e1910fcdf867805caab27c6340158d2&#34;&gt;滑动标签&lt;/h3&gt;

&lt;p&gt;APP总体底部的4个Fragment切换和在每个Fragment中的ViewPage切换, 采用的是LuckyJayce/ViewPagerIndicator的开源框架：地址是&lt;a href=&#34;https://github.com/LuckyJayce/ViewPagerIndicator&#34;&gt;ViewPagerIndicator&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然,若是初次接触，建议学习&lt;a href=&#34;https://developer.android.com/samples/SlidingTabsBasic/index.html&#34;&gt;SlidingTabsBasic&lt;/a&gt;,Google官方教程，简洁实现SlidingTab。&lt;/p&gt;

&lt;h3 id=&#34;列表实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;列表实现&lt;/h3&gt;

&lt;p&gt;新闻列表采用纵向RecyclerView，其中暂时划分为3种类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static enum ITEM_TYPE {
    ITEM_TYPE_BANNER,
    ITEM_TYPE_IMAGE,
    ITEM_TYPE_TEXT
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别表示以下3种类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BANNER：
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914143937664-372953191.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;TEXT：
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914143948320-1282950477.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IMAGE：
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914143954336-1896838803.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ITEM_TYPE_BANNER 采用自定义SwitchImage控件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ITEM_TYPE_TEXT 相对布局&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ITEM_TYPE_IMAGE 水平RecycleView （官方版本为三张图片）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;水平列表效果:0e1910fcdf867805caab27c6340158d2&#34;&gt;水平列表效果&lt;/h3&gt;

&lt;p&gt;本部分介绍ITEM_TYPE_IMAGE的水平滑动列表如何实现。
&lt;img src=&#34;http://images2015.cnblogs.com/blog/739642/201509/739642-20150914144420304-1934370299.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;经过一番努力，现已实现了列表能够响应以下三种情景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;滑动ITEM_TYPE_IMAGE时：
会先根据滑动夹角判断是水平滑动还是上下滑动。

&lt;ul&gt;
&lt;li&gt;如果是水平滑动。滑动时，水平列表滑动。如果水平列表滑动尽头，也不会触发新闻栏目的切换。&lt;/li&gt;
&lt;li&gt;如果是垂直滑动。则相应整个列表的上下滑动。&lt;/li&gt;
&lt;li&gt;如果用户滑动很短距离（很短时间）就抬起手指，则触发点击事件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;水平列表事件冲突处理:0e1910fcdf867805caab27c6340158d2&#34;&gt;水平列表事件冲突处理&lt;/h3&gt;

&lt;h4 id=&#34;1-实现方式:0e1910fcdf867805caab27c6340158d2&#34;&gt;1. 实现方式&lt;/h4&gt;

&lt;p&gt;水平滑动的处理方式一般有ViewPage，Gallery，HorizontalScrollview等几种。&lt;/p&gt;

&lt;p&gt;这里采用在垂直RecycleView中嵌套水平RecycleView。
主要的布局结构是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;layout.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-存在问题:0e1910fcdf867805caab27c6340158d2&#34;&gt;2.存在问题&lt;/h4&gt;

&lt;p&gt;如果不进行如何额外的处理，那么看上去一些正常。但是每次将水平列表滑动尽头并继续滑动时，会触发Viewpage的页面切换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;趁着寒假，已经把这个问题分析处理了。&lt;/strong&gt;
&lt;a href=&#34;http://freedomofme.github.io/开发/多重嵌套布局下滑动冲突解决方案和思路&#34;&gt;解决过程和思路完全复盘，值得一看！&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;  但是当我想对水平RecyclerView中的某张图片进行点击时，出现了onClick函数没有回调的问题，由于笔者水平和时间有限，暂时没有深究这个问题。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;于是采用了onTouch函数做点击响应的回调, 做了如下简单的判断：&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt; 用户是点击图片还是水平滑动RecyclerIView &lt;/del&gt;
&lt;del&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;imageView.setOnTouchListener(new View.OnTouchListener() {
  @Override
 public boolean onTouch(View v, MotionEvent event) {
  //抬起按钮时判断，之前是否滑动了,若没有滑动则响应点击事件
                if (event.getAction() == MotionEvent.ACTION_UP &amp;amp;&amp;amp; !isMoved)
                    mListener.onViewPageTouch((NetworkImageView) v, index);
                else {
                    isMoved = false;
                }
                if (event.getAction() == MotionEvent.ACTION_MOVE) {
                    isMoved = true;
                }
                return true;
            }
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;基于自定义volley预加载和回调刷新:0e1910fcdf867805caab27c6340158d2&#34;&gt;基于自定义Volley预加载和回调刷新&lt;/h3&gt;

&lt;h4 id=&#34;目前效果-1:0e1910fcdf867805caab27c6340158d2&#34;&gt;目前效果&lt;/h4&gt;

&lt;p&gt;首次打开APP时，先显示缓存内容，然后同时请求网络，显示最新内容。&lt;/p&gt;

&lt;h4 id=&#34;最简单的实现方案:0e1910fcdf867805caab27c6340158d2&#34;&gt;最简单的实现方案&lt;/h4&gt;

&lt;p&gt;一般的话，可能会使用数据库之类的存储结构来保存历史新闻。但是，我想简化这个过程，依赖于网络请求框架的缓存来实现。&lt;/p&gt;

&lt;p&gt;一开始想的是给修改Volley源码，为Response.Listener(T response)接口增加一个回调方法onCacheHit(T response)方案,如以下代码所示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public interface Listener&amp;lt;T&amp;gt; {
    /** Called when a response is received. */
    public void onResponse(T response);
    /** 存在缓存 */
    public void onCacheHit(T response);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，经过阅读Volley的源码，发现可以通过修改一个Response的softTTL和TTL来实现以上想法。&lt;/p&gt;

&lt;p&gt;于是根据这个想法，修改出了一个HandyVolley的框架，使用文档见于此处&amp;ndash;&lt;a href=&#34;https://github.com/freedomofme/HandyVolley&#34;&gt;HandyVolley&lt;/a&gt;，并发布于Jcente仓库中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;site.okhttp.codeyel:HandyVolley:1.0.3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;顶部沉浸式状态栏实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;顶部沉浸式状态栏实现&lt;/h3&gt;

&lt;p&gt;参考了这篇文章：
&lt;a href=&#34;http://www.jianshu.com/p/f8374d6267ef&#34;&gt;http://www.jianshu.com/p/f8374d6267ef&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;新闻详情实现:0e1910fcdf867805caab27c6340158d2&#34;&gt;新闻详情实现&lt;/h3&gt;

&lt;p&gt;首先，根据网络返回的数据的样式确定解析方案：&lt;/p&gt;

&lt;p&gt;NewsDisplayActivity.java第70行，展示了一个返回数据Html格式的样例：&lt;a href=&#34;https://github.com/freedomofme/Netease/commit/bb6db85de547d4d5243e17e881bc2116122e52d6&#34;&gt;https://github.com/freedomofme/Netease/commit/bb6db85de547d4d5243e17e881bc2116122e52d6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文采用的方法是通过Android自带的android.text.Html类解析Html和html下&lt;img&gt;标签的图像。
核心代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    URLImageParser p = new URLImageParser(content, this);
    Spanned htmlSpan = Html.fromHtml(body, p, null);
    content.setText(htmlSpan);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的URLImageParser是用来解析&lt;img&gt;标签的，这里有很大的进一步优化的空间。&lt;/p&gt;

&lt;p&gt;这类主要是参考该文，并修正了图片尺寸上的问题。&lt;a href=&#34;http://stackoverflow.com/questions/15617210/android-html-fromhtml-with-images/15617341#15617341&#34;&gt;http://stackoverflow.com/questions/15617210/android-html-fromhtml-with-images/15617341#15617341&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，除了用TextView来展示Html（在Android
中就是Spanned类），也可以使用WebView。
两者的主要区别：
* WebView：加载HTML更为方便（笔者觉得），支持的标签更多，与APP交互需要通过JS接口
* TextView： 除了文本显示，对于其他很多交互行为，需要重写函数。开发者对展示细节的控制能力更强。
详细内容可以参考:&lt;a href=&#34;https://www.ibm.com/developerworks/cn/web/1407_zhangqian_androidhtml/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;数据请求与相应:0e1910fcdf867805caab27c6340158d2&#34;&gt;数据请求与相应&lt;/h3&gt;

&lt;p&gt;采用的是Volley框架，并封装了RequestSingletonFactory工厂类来方便请求。
URLs类中采用反射的方式来读取静态URL的数据。&lt;/p&gt;

&lt;h3 id=&#34;接下来:0e1910fcdf867805caab27c6340158d2&#34;&gt;接下来&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;完善新闻阅读的排版，对于部分网页存在数据不兼容，导致解析的Bug&lt;/li&gt;
&lt;li&gt;增加查看新闻评论功能&lt;/li&gt;
&lt;li&gt;增加用户设置界面&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;下载地址:0e1910fcdf867805caab27c6340158d2&#34;&gt;下载地址&lt;/h3&gt;

&lt;p&gt;本项目将在持续更新，更加完善，项目源码地址：
&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;https://github.com/freedomofme/Netease&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本开源项目仅供学习，不得作为其他用途&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java重排序和happens-before学习思路</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Java%20%E9%87%8D%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Fri, 01 Apr 2016 19:52:07 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Java%20%E9%87%8D%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/</guid>
      <description>&lt;p&gt;鉴于在互联网上大家资料抄袭严重，本文主要介绍学习Java中的重排序和happens-before关系等相关概念的学习思路。建议大家看书系统学习。&lt;/p&gt;

&lt;p&gt;我觉得理解这些概念，比较好的思路是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;知道什么是重排序？
&amp;gt; 重排序是编译器和处理器为了优化性能而对指令执行顺序进行重新排序。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;现在你已经知道了什么是重排序，认识下重排序的发生位置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编译器重排序&lt;/li&gt;
&lt;li&gt;指令级并行重排序&lt;/li&gt;
&lt;li&gt;内存系统重排序&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;理解单线程程序中可能发生指令的重排序&lt;/p&gt;

&lt;p&gt;这就是说在单线程中，编译器也会进行重排序。但是为什么我以前写了这么久单线程的Java程序，都没有发现指令重排序这个问题？&lt;/p&gt;

&lt;p&gt;原因是java遵从as-if-serial语义，即单线程的程序即使发生了重排序，程序的执行结果不能被改变。所以，即使发生了重排序，执行结果是一样的，所以你感觉不到。&lt;/p&gt;

&lt;p&gt;比如说，对于有数据依赖的语句进行重排序，就会改变结果，所以会禁止此种情况的重排序。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;理解happens-before的定义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见。且第一个操作排在第二个操作之前。&lt;/li&gt;
&lt;li&gt;两个操作之间存在happens-before关系，如果重排序之后的对执行结果没有影响，也可以重排序。即表明不一定存在这个关系就一定不能重排序。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;happens-before规则&lt;/p&gt;

&lt;p&gt;这里有6条：程序次序规则；监视器锁规则；volatile规则；传递性规则等等。
比如：程序次序规则，它要求一个线程中的每个操作，happens-before该线程的任何后续操作。
这里大家去查阅详细资料。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;此时可能会有一个疑惑，既然多线程程序的先后语句满足happens-before规则中程序次序规则，为什么还会重排序？&lt;/p&gt;

&lt;p&gt;其实这个问题前面已经说了，第4点，在多线程程序中，也是由多个单线程组成的。他们中的每一个线程前后是存在happens-before规则。java以单线程的角度来看待这个问题：java认为对线程中语句进行重排序是不会改变结果的。&lt;/p&gt;

&lt;p&gt;因为java又不知道你这个代码是会在多线程里运行还是单线程里运行，它只保证单线程运行时，重排序后不改变执行结果，当这代码在多线程里运行时就可能出现问题。&lt;/p&gt;

&lt;p&gt;所以我们就需要在多线程中进行正确的同步的一个原因。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;学习volatile语义、锁的语义、和final的语义&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;此时就可惜学习java中的Thread的实现和并发容器的实现&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程一：a -&amp;gt; b -&amp;gt; c
线程二：A -&amp;gt; B -&amp;gt; C&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若没有重排序的结果可能是&lt;/p&gt;

&lt;p&gt;a -&amp;gt; A -&amp;gt; B -&amp;gt; b -&amp;gt; c -&amp;gt; C&lt;/p&gt;

&lt;p&gt;也就是单个线程的顺序不变&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若发生了重排序结果可能是&lt;/p&gt;

&lt;p&gt;b -&amp;gt; B -&amp;gt; A -&amp;gt; a -&amp;gt; c -&amp;gt; C&lt;/p&gt;

&lt;p&gt;就要分析里面的代码是否有happens-before的关系以及对每个单线程而言的重拍序是否会改变运行结果来分析。&lt;/p&gt;

&lt;p&gt;本文参考：《并发编写的艺术》&lt;/p&gt;

&lt;p&gt;欢迎批评指正：&lt;a href=&#34;mailto:xiegeixiong@gmail.com&#34;&gt;xiegeixiong@gmail.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何根据二叉树的中序和前序后序推导出整棵二叉树</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%8E%A8%E5%AF%BC%E5%87%BA%E6%95%B4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 01 Apr 2016 19:52:07 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%8E%A8%E5%AF%BC%E5%87%BA%E6%95%B4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>

&lt;p&gt;本文将主要介绍程序的主要计算流程。具体Android APP代码在&lt;a href=&#34;https://github.com/freedomofme/BinaryTreeTraverseCalculate&#34;&gt;请看这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;写作目的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当然是为了为了加深理解二叉树遍历啦&lt;/li&gt;
&lt;li&gt;因为受不了笔试题老出这种题目，所以做出来方便大家以后答题O(∩_∩)O~&lt;/li&gt;
&lt;li&gt;最关键的是，每次遇到这种题目，我只会凑./捂脸&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;so，我决定花一个小时，写个程序一劳永逸，结果还没写完，我就学会了，不需要它了，送给大家~&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先在知道中序的前提下，任意知道一个前序、后序，即可以构建整棵二叉树，也就知道了所有顺序的遍历。&lt;/p&gt;

&lt;h4 id=&#34;由前序中序推导:65af8147e2e31eeb70f80702d9fc030d&#34;&gt;由前序中序推导&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;已知一棵二叉树的前序序列和中序序列，构造该二叉树的过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;根据前序序列的第一个元素建立根结点；&lt;/li&gt;
&lt;li&gt;在中序序列中找到该元素，确定根结点的左右子树的中序序列；&lt;/li&gt;
&lt;li&gt;在前序序列中确定左右子树的前序序列；&lt;/li&gt;
&lt;li&gt;由左子树的前序序列和中序序列建立左子树；&lt;/li&gt;
&lt;li&gt;由右子树的前序序列和中序序列建立右子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;由后序中序推导:65af8147e2e31eeb70f80702d9fc030d&#34;&gt;由后序中序推导&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;已知一棵二叉树的后序序列和中序序列，构造该二叉树的过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;根据后序序列的最后一个元素建立根结点；&lt;/li&gt;
&lt;li&gt;在中序序列中找到该元素，确定根结点的左右子树的中序序列；&lt;/li&gt;
&lt;li&gt;在后序序列中确定左右子树的后序序列；&lt;/li&gt;
&lt;li&gt;由左子树的后序序列和中序序列建立左子树；&lt;/li&gt;
&lt;li&gt;由右子树的后序序列和中序序列建立右子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;引用自：&lt;a href=&#34;http://blog.sina.com.cn/s/blog_8c243ea30102uzwo.html&#34;&gt;http://blog.sina.com.cn/s/blog_8c243ea30102uzwo.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;核心代码:65af8147e2e31eeb70f80702d9fc030d&#34;&gt;核心代码&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public static void calPostOrder(String preString, String midString) {
    if (preString.length() == 0) return;
    if (preString.length() == 1) {
        result.add(preString.charAt(0));
    }
    if (preString.length() &amp;gt; 1) {
        //前序首字母拆分中序字符串           
        String[] resultStrings = midString.split(preString.charAt(0) + &amp;quot;&amp;quot;);
        for (int i = 0; i &amp;lt; resultStrings.length; i++) {
            String newPreString = findSubStringInPreORPostString(preString, resultStrings[i]);
            calPostOrder(newPreString, resultStrings[i]);
        }
        result.add(preString.charAt(0));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中findSubStringInPreORPostString()函数就是从先序字符串中取出对应中序的字符串的子串。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android 图像压缩，和LRU算法使用的推荐链接</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%20%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%EF%BC%8C%E5%92%8CLRU%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8E%A8%E8%8D%90%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sat, 02 Jan 2016 17:54:06 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%20%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%EF%BC%8C%E5%92%8CLRU%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8E%A8%E8%8D%90%E9%93%BE%E6%8E%A5/</guid>
      <description>&lt;p&gt;近两日，看的关于这些方面的一些教程数十篇，最好的当属google原版的教程了。国内有不少文章是翻译这个链接的。&lt;/p&gt;

&lt;p&gt;需要注意的一点是：Android的SDK中的LRU算法在V4包和Util包中各有一个，推荐使用V4包中的。&lt;/p&gt;

&lt;p&gt;在此，推荐两个链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/intl/ru/training/displaying-bitmaps/process-bitmap.html&#34;&gt;https://developer.android.com/intl/ru/training/displaying-bitmaps/process-bitmap.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://android-developers.blogspot.jp/2010/07/multithreading-for-performance.html&#34;&gt;http://android-developers.blogspot.jp/2010/07/multithreading-for-performance.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中，第二个链接是对第一个链接所讲内容的例子演示，下载地址我已经clone到我的github上了，看了会对内容理解的更加深刻，强烈欢迎下载。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/freedomofme/android-imagedownloader&#34;&gt;https://github.com/freedomofme/android-imagedownloader&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android图片适配，drawable文件夹，低分辨率图片是否必要</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D%EF%BC%8Cdrawable%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E4%BD%8E%E5%88%86%E8%BE%A8%E7%8E%87%E5%9B%BE%E7%89%87%E6%98%AF%E5%90%A6%E5%BF%85%E8%A6%81/</link>
      <pubDate>Sat, 02 Jan 2016 17:50:06 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D%EF%BC%8Cdrawable%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E4%BD%8E%E5%88%86%E8%BE%A8%E7%8E%87%E5%9B%BE%E7%89%87%E6%98%AF%E5%90%A6%E5%BF%85%E8%A6%81/</guid>
      <description>&lt;p&gt;我们知道，Android提供了几种不同分辨率的bitmap，来对应不同手机屏幕的密度。对应关系如下：&lt;/p&gt;

&lt;p&gt;xxhdpi:3.0
xhdpi: 2.0
hdpi: 1.5
mdpi: 1.0
ldpi: 0.75
于是一个问题产生了：&lt;/p&gt;

&lt;p&gt;从接触Android开发时就有了，既然Android能自动转换，为什么还要浪费用户空间去存储低分辨率的图片？&lt;/p&gt;

&lt;p&gt;查了一些资料，终于在Google的开发者网站上找到了解答：
&amp;gt;
Note: Low-density (ldpi) resources aren’t always necessary. When you provide hdpi assets, the system scales them down by one half to properly fit ldpi screens.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://developer.android.com/training/basics/supporting-devices/screens.html&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大概意思就是低分辨率的资源不是总是必要的，当你提供高分辨率的资源了，系统会缩放图片来适应低分率的屏幕。&lt;/p&gt;

&lt;p&gt;问题到此就解答完了。&lt;/p&gt;

&lt;p&gt;有个疑问：就是假如未放置了低分辨率图片，让系统需要时自动转换，是否影响响应速度（系统是否会缓存）？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android获取联系人示例，从数据库加载，带首字母标签</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%E8%8E%B7%E5%8F%96%E8%81%94%E7%B3%BB%E4%BA%BA%E7%A4%BA%E4%BE%8B%EF%BC%8C%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%B8%A6%E9%A6%96%E5%AD%97%E6%AF%8D%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Fri, 01 Jan 2016 17:59:26 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Android%E8%8E%B7%E5%8F%96%E8%81%94%E7%B3%BB%E4%BA%BA%E7%A4%BA%E4%BE%8B%EF%BC%8C%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%B8%A6%E9%A6%96%E5%AD%97%E6%AF%8D%E6%A0%87%E7%AD%BE/</guid>
      <description>

&lt;p&gt;这几天打算学习下Android联系人方面的一些东西，之前稍有涉略，不过每次都是浅尝辄止。&lt;/p&gt;

&lt;p&gt;推荐国内两个Link：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fanfq.iteye.com/blog/779569&#34;&gt;Link1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.icodelogic.com/?p=453&#34;&gt;Link2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上两个都是读取联系人。&lt;/p&gt;

&lt;p&gt;第一个Link采用多次查询每次查询一条数据的方式，比较好理解，但是效率底。250条记录（6s）&lt;/p&gt;

&lt;p&gt;第二个Link采用的Querying entities，返回数据集，大大减少了查询次数。250条记录（200ms）。因为采用了联接的数据库查询方式（不大熟悉的话可以温习下数据库方面的知识），大大减少了查询次数。&lt;/p&gt;

&lt;p&gt;google上有对contacts的比较详细的教材,也有讲到到
Querying entities：&lt;a href=&#34;http://developer.android.com/intl/zh-cn/guide/topics/providers/contacts-provider.html&#34;&gt;http://developer.android.com/intl/zh-cn/guide/topics/providers/contacts-provider.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;推荐《精通Android》书里的介绍也不错&lt;/p&gt;

&lt;h3 id=&#34;demo:637a22d20c7bd1c4d18680e663810998&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;根据最开始的两个link，做成一个Demo，给大家参考和批评：&lt;/p&gt;

&lt;p&gt;Demo下载地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://files.cnblogs.com/files/FightForFreedom/ContactsDataBase.zip&#34;&gt;http://files.cnblogs.com/files/FightForFreedom/ContactsDataBase.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;截图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://images0.cnblogs.com/blog2015/739642/201508/091350416436298.png&#34; alt=&#34;http://images0.cnblogs.com/blog2015/739642/201508/091350416436298.png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字符集乱码问题:ISO-8859-1和GBK</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98-ISO-8859-1%E5%92%8CGBK/</link>
      <pubDate>Fri, 01 Jan 2016 17:59:16 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98-ISO-8859-1%E5%92%8CGBK/</guid>
      <description>

&lt;p&gt;首先引用百度知道的问题：
&amp;gt;
&lt;a href=&#34;http://zhidao.baidu.com/question/51342167.html?qbl=relate_question_0&amp;amp;word=%C3%84%C3%A3%C2%BA%C3%83%20%E4%B9%B1%E7%A0%81&#34;&gt;帮忙翻译 ÄãºÃ£¬¿Í»§ÉÐÔ&amp;amp;Uacu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;即：出现了以下字符乱码
ÄãºÃ£¬¿Í»§ÉÐÔÚ¿¼ÂÇÖÐ£¬Ð»Ð»£¡
如何解决？&lt;/p&gt;

&lt;h3 id=&#34;方法一:e4ec21571305cc652d1ed9bd63a35f48&#34;&gt;方法一：&lt;/h3&gt;

&lt;p&gt;String s_iso88591 = new String(&amp;ldquo;ÄãºÃ£¬¿Í»§ÉÐÔÚ¿¼ÂÇÖÐ£¬Ð»Ð»£¡ &amp;ldquo;.getBytes(&amp;ldquo;ISO-8859-1&amp;rdquo;),&amp;ldquo;GBK&amp;rdquo;);
输出s_iso88591即可。&lt;/p&gt;

&lt;h3 id=&#34;方法二:e4ec21571305cc652d1ed9bd63a35f48&#34;&gt;方法二：&lt;/h3&gt;

&lt;p&gt;String testString = &amp;ldquo;你好&amp;rdquo;;
byte[] hold = testString.getBytes(&amp;ldquo;GBK&amp;rdquo;);
for (int i = 0 ; i &amp;lt; hold.length; i++) {
System.out.println((char)(256 + hold[i]));
}
输出: ÄãºÃ&lt;/p&gt;

&lt;p&gt;由此可见好好理解字符集还是相当必要的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅谈Java对象回收的三种方式</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E6%B5%85%E8%B0%88Java%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Fri, 01 Jan 2016 17:59:06 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E6%B5%85%E8%B0%88Java%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>

&lt;p&gt;最近在看Java虚拟机，写点给新手和自己看的东西。&lt;/p&gt;

&lt;h3 id=&#34;第一类-生命周期中止:6029cb9672493498e7785f8d23b0964a&#34;&gt;第一类：生命周期中止&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;void scope（）{
    Test t = new Test();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第二类-对象无引用:6029cb9672493498e7785f8d23b0964a&#34;&gt;第二类：对象无引用&lt;/h3&gt;

&lt;h5 id=&#34;对象的应用被转移:6029cb9672493498e7785f8d23b0964a&#34;&gt;对象的应用被转移：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;void life（）{
   Test t = new Test();
    t = new Test();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;对象被赋值为null:6029cb9672493498e7785f8d23b0964a&#34;&gt;对象被赋值为null&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;void scope（）{
   Test t = new Test();
   t = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于Android的ListView中CheckBox错乱</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%85%B3%E4%BA%8EAndroid%E7%9A%84ListView%E4%B8%ADCheckBox%E9%94%99%E4%B9%B1/</link>
      <pubDate>Fri, 01 Jan 2016 17:57:45 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E5%85%B3%E4%BA%8EAndroid%E7%9A%84ListView%E4%B8%ADCheckBox%E9%94%99%E4%B9%B1/</guid>
      <description>

&lt;p&gt;本文参考：
&amp;gt; &lt;a href=&#34;http://www.cnblogs.com/xiaowenji/archive/2010/12/08/1900579.html&#34;&gt;ListView中getView的原理＋如何在ListView中放置多个item&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上文中关于说的Android中的Recycler比较模糊，Android会维持屏幕中显示的item+1个对象。但是具体的复用机制没有介绍，建议阅读源码学习。&lt;/p&gt;

&lt;h3 id=&#34;关于checkbox-选中了之后-下滑之后返回就消失的问题:26155ffc16647da895c63731007e82b8&#34;&gt;关于checkBox，选中了之后，下滑之后返回就消失的问题。&lt;/h3&gt;

&lt;p&gt;有以下两种方式供大家参考：&lt;/p&gt;

&lt;p&gt;data是给TextView显示的数据&lt;/p&gt;

&lt;p&gt;isChecked是用来记录CheckBox是否选中的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayList&amp;lt;String&amp;gt; data;
ArrayList&amp;lt;Boolean&amp;gt; isChecked;
 class Holder {
        TextView name;
        CheckBox box;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h4 id=&#34;方法一:26155ffc16647da895c63731007e82b8&#34;&gt;方法一：&lt;/h4&gt;

&lt;p&gt;用onClickedListener,使用这个监听器可以简单的避开CheckedBox选中消失的问题。&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;holder.box.setTag(i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用来给监听器指明选择的索引。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Override
    public View getView(int i, View view, ViewGroup viewGroup) {
        if(view == null) {
            view = LayoutInflater.from(context).inflate(R.layout.list_item, null);
            holder = new Holder();
            holder.box = (CheckBox) view.findViewById(R.id.cb_isChecked);
            holder.name = (TextView) view.findViewById(R.id.tv_name);
            view.setTag(holder);
        } else {
            holder = (Holder) view.getTag();
        }
        holder.name.setText(data.get(i));
        System.out.println(&amp;quot;即将改变成&amp;quot; + isChecked.get(i) + &amp;quot;i&amp;quot; + i);
        holder.box.setChecked(isChecked.get(i));
　　
        holder.box.setTag(i);
        holder.box.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                boolean hold = isChecked.get((Integer) view.getTag());
                isChecked.set((Integer) view.getTag(), !hold);
                System.out.println(&amp;quot;compoundButton.getTag()&amp;quot; + view.getTag());
            }
        });
        return view;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;方法二:26155ffc16647da895c63731007e82b8&#34;&gt;方法二：&lt;/h4&gt;

&lt;p&gt;继续使用onCheckedListener这个监听器，需要注意一些问题。&lt;/p&gt;

&lt;p&gt;代码：和上面的一样，就是把onClickListener改成onCheckedlistener，结果就出现了选中消失的问题。&lt;/p&gt;

&lt;p&gt;仔细看了在logcat中看了输出的结果，发现问题的所在：&lt;/p&gt;

&lt;p&gt;当我们选中一个item时，假设此时item1被选中，下拉列表，到时item1隐藏，item10出现，并复用了item1的结构。&lt;/p&gt;

&lt;p&gt;由于在getView函数中item10被赋值是false，此时，onCheckedListener监听器响应了（如果使用onClickedListener就没有以下问题，因为它再此时不会响应）。&lt;/p&gt;

&lt;p&gt;问题来了：&lt;/p&gt;

&lt;p&gt;因为在onCheckedListener根据view.getTag()来获得索引，而此时的索引是1，就是item1对象时setTag时留下的。&lt;/p&gt;

&lt;p&gt;最终导致此时监听器把用来存储布尔值的线性表的索引1的位置赋值成了item10的值。&lt;/p&gt;

&lt;p&gt;根据问题的成因，我们需要在 onCheckedListener响应前，让view.getTag()获得正确的索引。&lt;/p&gt;

&lt;p&gt;其实很简单只需要将&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;holder.box.setTag(i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;放到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;holder.box.setChecked(isChecked.get(i));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面就可以了。
  此解决方案的完整代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ListAdapter2 extends BaseAdapter {
    ArrayList&amp;lt;String&amp;gt; data;
    ArrayList&amp;lt;Boolean&amp;gt; isChecked;
    Context context;
    Holder holder;
    public ListAdapter2(Context context, ArrayList&amp;lt;String&amp;gt; data, ArrayList&amp;lt;Boolean&amp;gt; isChecked) {
        this.context = context;
        this.data = data;
        this.isChecked = isChecked;
    }

@Override
public int getCount() {
    return data.size();
}

@Override
public Object getItem(int i) {
    return data.get(i);
}

@Override
public long getItemId(int i) {
    return i;
}

@Override
public View getView(int i, View view, ViewGroup viewGroup) {
    if(view == null) {
        view = LayoutInflater.from(context).inflate(R.layout.list_item, null);
        holder = new Holder();
        holder.box = (CheckBox) view.findViewById(R.id.cb_isChecked);
        holder.name = (TextView) view.findViewById(R.id.tv_name);
        view.setTag(holder);

    } else {
        holder = (Holder) view.getTag();
    }

    holder.name.setText(data.get(i));
    System.out.println(&amp;quot;即将改变成&amp;quot; + isChecked.get(i) + &amp;quot;i&amp;quot; + i);
    holder.box.setTag(i);

    holder.box.setChecked(isChecked.get(i));

    holder.box.setOnCheckedChangeListener(new CheckedListener());
    return view;
}

class CheckedListener implements CompoundButton.OnCheckedChangeListener {
    @Override
    public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
        isChecked.set((Integer) compoundButton.getTag(), b);
    }
}

class Holder {
    TextView name;
    CheckBox box;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　
　　&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Anroid自定义RatingBar，显示半个（小数个）的stepSize时，变为整数个的问题</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Anroid%E8%87%AA%E5%AE%9A%E4%B9%89RatingBar%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%8D%8A%E4%B8%AA%EF%BC%88%E5%B0%8F%E6%95%B0%E4%B8%AA%EF%BC%89%E7%9A%84stepSize%E6%97%B6%EF%BC%8C%E5%8F%98%E4%B8%BA%E6%95%B4%E6%95%B0%E4%B8%AA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 01 Jan 2016 17:52:06 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/Anroid%E8%87%AA%E5%AE%9A%E4%B9%89RatingBar%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%8D%8A%E4%B8%AA%EF%BC%88%E5%B0%8F%E6%95%B0%E4%B8%AA%EF%BC%89%E7%9A%84stepSize%E6%97%B6%EF%BC%8C%E5%8F%98%E4%B8%BA%E6%95%B4%E6%95%B0%E4%B8%AA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;&lt;RatingBar
        android:id=&#34;@+id/rb_starbar&#34;
        style=&#34;@style/joblist_item_ratingbar_style&#34;
        android:layout_width=&#34;wrap_content&#34;
        android:layout_height=&#34;wrap_content&#34;
        android:isIndicator=&#34;false&#34;
        android:numStars=&#34;5&#34;
        android:rating=&#34;3.5&#34;
        android:stepSize=&#34;0.5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;RatingBar一般都是显示整数个数的，这次因为要显示半个的Star，就把之前的样式改了一改，结果，出现了问题：&lt;/p&gt;

&lt;p&gt;无论怎么设置setpSize的值，每次显示的Star都是整个的。。
当使用以下样式时：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;item
    android:id=&amp;quot;@+android:id/background&amp;quot;
    android:drawable=&amp;quot;@drawable/ic_gray&amp;quot;&amp;gt;
&amp;lt;/item&amp;gt;
&amp;lt;item
    android:id=&amp;quot;@+android:id/secondaryProgress&amp;quot;
    android:drawable=&amp;quot;@drawable/ic_orange&amp;quot;&amp;gt;
&amp;lt;/item&amp;gt;
&amp;lt;item
    android:id=&amp;quot;@+android:id/progress&amp;quot;
    android:drawable=&amp;quot;@drawable/ic_orange&amp;quot;&amp;gt;
&amp;lt;/item&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ic_orange：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://images0.cnblogs.com/blog2015/739642/201505/310034043608696.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ic_gray：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://images0.cnblogs.com/blog2015/739642/201505/310034363138191.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ic_setting：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://images0.cnblogs.com/blog2015/739642/201505/310034509383960.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;结果是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://images0.cnblogs.com/blog2015/739642/201505/310023291579837.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为什么没有显示3.5个Star(=@__@=)？看了下Google的文档解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;android:secondaryProgress Defines the secondary progress value, between 0 and max.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下来替换secondaryProgress的drawable，看下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;item
        android:id=&amp;quot;@+android:id/secondaryProgress&amp;quot;
        android:drawable=&amp;quot;@drawable/ic_setting&amp;quot;&amp;gt;
  &amp;lt;/item&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：
&lt;img src=&#34;http://images0.cnblogs.com/blog2015/739642/201505/310027290631131.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此处的secondaryProgress会向上取整(Math.cell())的显示图像。&lt;/p&gt;

&lt;p&gt;如此，一开始的问题也就迎刃而解了。&lt;/p&gt;

&lt;p&gt;以下为正确的XML文件配置代码：&lt;/p&gt;

&lt;p&gt;（下面的secondaryProgress部分和第一个secondaryProgress，已经调换的drawable。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;item
    android:id=&amp;quot;@+android:id/background&amp;quot;
    android:drawable=&amp;quot;@drawable/ic_gray&amp;quot;&amp;gt;
&amp;lt;/item&amp;gt;
&amp;lt;item
    android:id=&amp;quot;@+android:id/secondaryProgress&amp;quot;
    android:drawable=&amp;quot;@drawable/ic_gray&amp;quot;&amp;gt;
&amp;lt;/item&amp;gt;
&amp;lt;item
    android:id=&amp;quot;@+android:id/progress&amp;quot;
    android:drawable=&amp;quot;@drawable/ic_orang&amp;quot;&amp;gt;
&amp;lt;/item&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>