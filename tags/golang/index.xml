<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Coder Yel</title>
    <link>http://freedomofme.github.io/tags/golang/</link>
    <description>Recent content in Golang on Coder Yel</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Jan 2017 17:45:23 +0800</lastBuildDate>
    <atom:link href="http://freedomofme.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>自定义Volley库--HandyVolley</title>
      <link>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E8%87%AA%E5%AE%9A%E4%B9%89Volley/</link>
      <pubDate>Tue, 17 Jan 2017 17:45:23 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E5%BC%80%E5%8F%91/%E8%87%AA%E5%AE%9A%E4%B9%89Volley/</guid>
      <description>

&lt;p&gt;本文主要介绍了一个为&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;仿网易新闻APP&lt;/a&gt;的而定制的Volley框架。&lt;/p&gt;

&lt;p&gt;这也是为什么要去修改一个2013年发布的老框架的原因，主要是为了兼容以前的代码。（如果是新上线没有历史负担的项目，网络库(retrofit等)和图片库(glide)等库的性能要更优秀。）&lt;/p&gt;

&lt;h3 id=&#34;一-介绍:30f9bd4fc8a12ae0d75da9a861d2ea0a&#34;&gt;一、介绍&lt;/h3&gt;

&lt;p&gt;本项目的基于2016年12月29号的原版Volley库开发，也是截止目前的最新版本。从提交日志来看项目代码基于稳定，不会存在重大缺陷。&lt;/p&gt;

&lt;p&gt;目前项目最新版本为1.0.3版本，后期可以会针对做一些微小的优化调整。
本项目兼容原版Volley库的API。&lt;/p&gt;

&lt;p&gt;已经把项目托管于Jcenter仓库，Android项目的话可以用以下语句在Gradle 中引用该项目库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;site.okhttp.codeyel:HandyVolley:1.0.3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第二类-更新细节:30f9bd4fc8a12ae0d75da9a861d2ea0a&#34;&gt;第二类：更新细节&lt;/h3&gt;

&lt;h5 id=&#34;1-0-0:30f9bd4fc8a12ae0d75da9a861d2ea0a&#34;&gt;1.0.0&lt;/h5&gt;

&lt;p&gt;Fork基于2016年12月29号的原版Volley库&lt;/p&gt;

&lt;h5 id=&#34;1-0-1:30f9bd4fc8a12ae0d75da9a861d2ea0a&#34;&gt;1.0.1&lt;/h5&gt;

&lt;p&gt;更新compileSdkVersion为23&lt;/p&gt;

&lt;h5 id=&#34;1-0-2:30f9bd4fc8a12ae0d75da9a861d2ea0a&#34;&gt;1.0.2&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;增加初始化时的磁盘缓存大小设置&lt;/li&gt;
&lt;li&gt;增加磁盘缓存控制策略：自定义网络响应的Ttl和softTtl。&lt;/li&gt;
&lt;li&gt;增加自定义的缓存设置相对于服务器的缓存策略的优先级控制&lt;/li&gt;
&lt;li&gt;对用户设置不缓存的请求，跳过响应解析操作，微小提升性能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;1-0-3-stable:30f9bd4fc8a12ae0d75da9a861d2ea0a&#34;&gt;1.0.3（Stable）&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;将1.0.2的缓存策略应用于对ImageLoader类&lt;/li&gt;
&lt;li&gt;修复缓存控制Bug&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用样例:30f9bd4fc8a12ae0d75da9a861d2ea0a&#34;&gt;使用样例&lt;/h3&gt;

&lt;p&gt;经介绍区别于原本Volley的使用方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加初始化时的磁盘缓存大小设置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改方式:Volley.java文件中增加newRequestQueue方法的重载方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxCacheSizeInBytes) 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用方法（其中第三个参数表示瓷片缓存大小为30MB）
    mRequestQueue = Volley.newRequestQueue(mCtx.getApplicationContext(), null, 30 * 1024 * 1024);&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.增加磁盘缓存控制策略：自定义网络响应的Ttl和softTtl&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ttl和softTtl说明
Ttl和softTtl用来用户自定义缓存时间，通常softTtl &amp;lt;= Ttl。
当一个请求的过期时间 &amp;gt; Ttl, 则重新请求服务器。
当一个请求的过期时间 &amp;gt; softTtl &amp;amp;&amp;amp; &amp;lt; Ttl, 则先使用缓存数据做出响应，并同时将该请求发送服务器。（也就是说，响应回调函数会触发两次）
当一个请求的过期时间 &amp;gt; softTtl，则直接使用本地缓存。&lt;/p&gt;

&lt;p&gt;根据以上特性，通过设置恰当的Ttl和softTtl，APP可以实现数据的及时展现和刷新。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改细节&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Request.java 增加以下三个属性值和相应的getter：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** this request&#39;s default Soft time limit(unit m       illisecond) if no cache control set by web severs*/
private int mDefaultSoftTtl = 0;


/** this request&#39;s default time limit(unit millisecond) if no cache control set by web severs*/
private int mDefaultTtl = 0;


/**
* Returns true means use the default TTL and soft TTL regardless of the server&#39;s cache control.
* Returns false means server&#39;s cache control has higher priority.
*/
private boolean localCacheControl = false;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;/**
* Returns true if responses to this request should be cached.
*/
public final boolean shouldCache() {
return mShouldCache;
}


/**
* Return this request&#39;s soft time limit (unit seconds).
*/
public int getDefaultSoftTtl() {
  return mDefaultSoftTtl;
}


/**
* Returns this request&#39;s the time limit (unit seconds).
 */
public int getDefaultTtl() {
return mDefaultTtl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中mDefaultSoftTtl表示默认的软缓存时间(单位毫秒)，mDefaultTtl表示默认的缓存时间(单位毫秒)，localCacheControl表示当mDefaultSoftTtl、mDefaultTtl的值和服务器返回的缓存策略冲突时，应该采用哪个数值。（怕大家看不懂我写的蹩脚英文，翻译一下）&lt;/p&gt;

&lt;p&gt;2.同理，在ImageLoader中也增加了以上三个属性和相应的getter。&lt;/p&gt;

&lt;p&gt;方法原型如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
    * Constructs a new ImageLoader.
    * @param queue The RequestQueue to use for making image requests.
    * @param imageCache The cache to use as an L1 cache.
    * @param  defaultSoftTtl this request&#39;s time limit (unit seconds).
    * @param  defaultTtl this request&#39;s soft time limit (unit seconds).
    * @param useLocalCacheControl Returns this request&#39;s cache control priority.
    */
    public ImageLoader(RequestQueue queue, ImageCache imageCache, int defaultSoftTtl, int defaultTtl, boolean useLocalCacheControl) {
        mRequestQueue = queue;
        mCache = imageCache;
        mDefaultSoftTtl = defaultSoftTtl;
        mDefaultTtl = defaultTtl;
        localCacheControl = useLocalCacheControl;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于不经过ImageLoader的Request，如StringRequest，直接覆写Request&lt;T&gt;属性的getter方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new StringRequest(Request.Method.GET, url, responseListener, new DefaultErrorListener(context)) {
    @Override
    public int getDefaultTtl() {
        return 15 * 24 * 3600 * 1000;
    }
    @Override
    public int getDefaultSoftTtl() {
        return 1 * 60 * 1000;
    }
    @Override
    public boolean shouldLocalCacheControl() {
        return true;
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上StringRequest表示默认缓存时间15天，默认软缓存时间1分钟，当与服务器的cache-control冲突时采用此数据为准。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于经过ImageLoader的Request，直接调用ImageLoader的另一个构造方法。&lt;/p&gt;

&lt;p&gt;mImageLoader = new ImageLoader(mRequestQueue, new MyLrnCache(mCtx), 1 * 3600 * 1000, 15 * 24 * 3600 * 1000, true);&lt;/p&gt;

&lt;p&gt;以上ImageLoader表示默认缓存时间15天，默认软缓存时间1小时，当与服务器的cache-control冲突时采用此数据为准。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实际案例&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/freedomofme/Netease&#34;&gt;Netease&amp;ndash;仿网易新闻Android端APP&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>记Screen命令简单流程</title>
      <link>http://freedomofme.github.io/%E6%9D%82%E6%96%87/%E8%AE%B0Screen%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sat, 13 Aug 2016 01:59:36 +0800</pubDate>
      
      <guid>http://freedomofme.github.io/%E6%9D%82%E6%96%87/%E8%AE%B0Screen%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B/</guid>
      <description>

&lt;p&gt;&lt;em&gt;明天还要去加班，今夜如此迷人，不敢轻易入睡。Screen误我啊&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;之前一直用Nohup这类简单的命令来后台执行命令。不过最近想抓点东西，后来做个分词，企图发现点什么好玩的东西。你懂得，七夕节，无非就是抓点男女之间的情话。&lt;/p&gt;

&lt;p&gt;结果手头没有爬虫框架，没有代理。。。悲剧，还记得上次自己好好认真写的时候是为了给自己人人网刷票（这网站就是运营、转型不善的电信代表，豆瓣也是类似）。然后就是用Java随便鼓捣了一点(别问我威慑呢么没用Python。。)&lt;/p&gt;

&lt;p&gt;花了二三个小时写好了，打了个jar包，笔记本没电电源，估计跑不到明天早晨回公司就会没电。。。才想起来之前买了一个云服务器，结果ssh连接之后没法后台执行程序。要是以往的话，应该就是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ctrl + Z，然后bg命令了。&lt;/li&gt;
&lt;li&gt;Nohup命令，不过NoHup在关闭了终端之后没法重新回到之前的后台任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过搜索了，发现Screen不错，就试试。&lt;/p&gt;

&lt;h3 id=&#34;正经点-虽然没人看:3bbaff0247f0606dae87a6b87084fdcf&#34;&gt;正经点，虽然没人看&lt;/h3&gt;

&lt;h5 id=&#34;准备:3bbaff0247f0606dae87a6b87084fdcf&#34;&gt;准备&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;安装: 过程请见文末链接。&lt;/li&gt;
&lt;li&gt;结构：Screen可以可以管理多个screen，一个screen可以拥有多个windows。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;开始使用:3bbaff0247f0606dae87a6b87084fdcf&#34;&gt;开始使用&lt;/h5&gt;

&lt;p&gt;将常用命令记录于下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;screen -list 列出screen的基本情况&lt;/li&gt;
&lt;li&gt;screen -t name 新建一个名为name的screen&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后c 在当前screen中新建windows&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后” &amp;ldquo;(双引号) “ 列出当前screen的windows，可以在此切换windows&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后”k“ 删除当前screen的某一个windows。如果一个screen的所有windows都被删除了，那么该screen也会被删除。&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后”A“ 对windows重命名&lt;/li&gt;
&lt;li&gt;Ctrl-a，然后”d“ 退出当前screen 保持后台运行&lt;/li&gt;
&lt;li&gt;screen -r 重新连接一个screen&lt;/li&gt;
&lt;li&gt;screen -p ID 重新连接特定的screen，其中的 ID 是一个数字或名称。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;详细记载请见IBM的developerworks资料库：
&lt;a href=&#34;https://www.ibm.com/developerworks/cn/aix/library/au-gnu_screen/&#34;&gt;https://www.ibm.com/developerworks/cn/aix/library/au-gnu_screen/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>